diff -ru irssi-0.7.11/src/gui-gnome/Makefile.am irssi-0.7.11-new/src/gui-gnome/Makefile.am
--- irssi-0.7.11/src/gui-gnome/Makefile.am	Sun Jun  6 18:48:07 1999
+++ irssi-0.7.11-new/src/gui-gnome/Makefile.am	Mon Jun  7 18:33:41 1999
@@ -53,7 +52,8 @@
         gui-mainwindows.c \
         gui-printtext.c \
         gui-server.c \
-        gui-windows.c \
+        gui-windowset.c \
+        gui-windows-view.c \
 	irssi.c \
         setup-appearance.c \
         setup-ircproxy.c \
@@ -98,7 +98,8 @@
         gui-mainwindows.h \
         gui-printtext.h \
         gui-server.h \
-        gui-windows.h \
+        gui-windowset.h \
+        gui-windows-view.h \
 	gtk-specific.h \
 	gnome-specific.h \
 	irssi.h \
diff -ru irssi-0.7.11/src/gui-gnome/channels-newdata.c irssi-0.7.11-new/src/gui-gnome/channels-newdata.c
--- irssi-0.7.11/src/gui-gnome/channels-newdata.c	Sat May 15 20:23:24 1999
+++ irssi-0.7.11-new/src/gui-gnome/channels-newdata.c	Sat Jun 12 17:55:06 1999
@@ -57,7 +57,7 @@
     g_return_val_if_fail(channel != NULL, FALSE);
 
     label = gtk_notebook_get_tab_label(GTK_NOTEBOOK(WINDOW_GUI(CHANNEL_PARENT(channel))->parent->notebook),
-                                       WINDOW_GUI(CHANNEL_PARENT(channel))->window);
+                                       WINDOW_GUI(CHANNEL_PARENT(channel))->windowset->window);
     newdata_label_colorify(channel, label);
 
     return TRUE;
diff -ru irssi-0.7.11/src/gui-gnome/dialog-channels.c irssi-0.7.11-new/src/gui-gnome/dialog-channels.c
--- irssi-0.7.11/src/gui-gnome/dialog-channels.c	Wed May 12 17:54:45 1999
+++ irssi-0.7.11-new/src/gui-gnome/dialog-channels.c	Mon Jun  7 18:57:46 1999
@@ -617,7 +617,7 @@
     {
         /* channel specific background pixmap */
         path = convert_home(rec->background);
-        gui_window_set_background_pixmap(CHANNEL_PARENT(channel), path);
+        gui_window_view_set_background_pixmap(WINDOW_GUI(CHANNEL_PARENT(channel)), path);
         g_free(path);
     }
 
diff -ru irssi-0.7.11/src/gui-gnome/dialog-textwidget.c irssi-0.7.11-new/src/gui-gnome/dialog-textwidget.c
--- irssi-0.7.11/src/gui-gnome/dialog-textwidget.c	Thu May 13 14:46:51 1999
+++ irssi-0.7.11-new/src/gui-gnome/dialog-textwidget.c	Sat Jun 12 17:26:21 1999
@@ -134,7 +134,7 @@
         return;
     }
 
-    if (WINDOW_GUI(window->active)->zvt)
+    if (window->active->active->zvt)
     {
         gui_dialog(DIALOG_ERROR, "Find doesn't work with ZVT windows yet");
         return;
@@ -145,7 +145,7 @@
                          GNOME_STOCK_BUTTON_CLOSE, NULL);
     gtk_signal_connect(GTK_OBJECT(dialog), "delete_event",
                        GTK_SIGNAL_FUNC(gtk_widget_destroy), NULL);
-    gui_widget_depends_data(dialog, "window destroyed", window->active);
+    gui_widget_depends_data(dialog, "window destroyed", window->active->active->window);
 
     hbox = gtk_hbox_new(FALSE, 0);
     gtk_box_pack_start(GTK_BOX(GNOME_DIALOG(dialog)->vbox), hbox, TRUE, TRUE, 0);
@@ -160,8 +160,8 @@
     gnome_dialog_button_connect_object(GNOME_DIALOG(dialog), 1, sig_find_next, GTK_OBJECT(dialog));
     gnome_dialog_button_connect_object(GNOME_DIALOG(dialog), 2, GTK_SIGNAL_FUNC(gtk_widget_destroy), GTK_OBJECT(dialog));
 
-    gtk_object_set_data(GTK_OBJECT(dialog), "text", WINDOW_GUI(window->active)->text);
-    gtk_object_set_data(GTK_OBJECT(dialog), "window", window->active);
+    gtk_object_set_data(GTK_OBJECT(dialog), "text", window->active->active->text);
+    gtk_object_set_data(GTK_OBJECT(dialog), "window", window->active->active->window);
     gtk_object_set_data(GTK_OBJECT(dialog), "entry", entry);
 
     gtk_widget_show_all(dialog);
@@ -220,13 +220,13 @@
         return;
     }
 
-    if (WINDOW_GUI(window->active)->zvt)
+    if (window->active->active->zvt)
     {
         gui_dialog(DIALOG_ERROR, "Save doesn't work with ZVT windows yet");
         return;
     }
 
-    if (gtk_text_get_length(GTK_TEXT(WINDOW_GUI(window->active)->text)) == 0)
+    if (gtk_text_get_length(GTK_TEXT(window->active->active->text)) == 0)
     {
         gui_dialog(DIALOG_OK, _("Window doesn't have any text"));
         return;
@@ -236,12 +236,12 @@
                                             GNOME_STOCK_BUTTON_CANCEL, NULL);
     gtk_signal_connect(GTK_OBJECT(dialog), "delete_event",
                        GTK_SIGNAL_FUNC(gtk_widget_destroy), NULL);
-    gui_widget_depends_data(dialog, "window destroyed", window->active);
+    gui_widget_depends_data(dialog, "window destroyed", window->active->active->window);
 
     button = gtk_check_button_new_with_label(_("Save only selected text"));
     gtk_box_pack_start(GTK_BOX(GNOME_DIALOG(dialog)->vbox), button, FALSE, FALSE, 0);
 
-    if (GTK_EDITABLE(WINDOW_GUI(window->active)->text)->has_selection)
+    if (GTK_EDITABLE(window->active->active->text)->has_selection)
         gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
     else
         gtk_widget_set_sensitive(button, FALSE);
@@ -258,7 +258,7 @@
     gnome_dialog_button_connect_object(GNOME_DIALOG(dialog), 0, sig_save_ok, GTK_OBJECT(dialog));
     gnome_dialog_button_connect_object(GNOME_DIALOG(dialog), 1, GTK_SIGNAL_FUNC(gtk_widget_destroy), GTK_OBJECT(dialog));
 
-    gtk_object_set_data(GTK_OBJECT(dialog), "text", WINDOW_GUI(window->active)->text);
+    gtk_object_set_data(GTK_OBJECT(dialog), "text", window->active->active->text);
     gtk_object_set_data(GTK_OBJECT(dialog), "selbut", button);
     gtk_object_set_data(GTK_OBJECT(dialog), "entry", gnome_file_entry_gtk_entry(GNOME_FILE_ENTRY(entry)));
 
diff -ru irssi-0.7.11/src/gui-gnome/dialog-window.c irssi-0.7.11-new/src/gui-gnome/dialog-window.c
--- irssi-0.7.11/src/gui-gnome/dialog-window.c	Sun Jun  6 18:34:26 1999
+++ irssi-0.7.11-new/src/gui-gnome/dialog-window.c	Sat Jun 12 17:28:12 1999
@@ -108,13 +108,13 @@
     hbox2 = gtk_hbox_new(FALSE, 5);
     gtk_box_pack_start(GTK_BOX(hbox), hbox2, TRUE, TRUE, 0);
 
-    str = g_strdup_printf("%d", WINDOW_GUI(window->active)->text->allocation.width);
+    str = g_strdup_printf("%d", window->active->active->text->allocation.width);
     entry = gui_create_labelentry(hbox2, _("Width"), str, TRUE);
     gtk_object_set_data(GTK_OBJECT(dialog), "sizexentry", entry);
     gtk_widget_set_usize(entry, 50, -1);
     g_free(str);
 
-    str = g_strdup_printf("%d", WINDOW_GUI(window->active)->text->allocation.height);
+    str = g_strdup_printf("%d", window->active->active->text->allocation.height);
     entry = gui_create_labelentry(hbox2, _("Height"), str, TRUE);
     gtk_object_set_data(GTK_OBJECT(dialog), "sizeyentry", entry);
     gtk_widget_set_usize(entry, 50, -1);
@@ -154,7 +154,7 @@
     gtk_widget_set_sensitive(hbox2, FALSE);
 
     /* window name */
-    channel = window->active->active;
+    channel = window->active->active->window->active;
     name = gui_channel_get_name(channel);
     if (name == NULL) name = "default";
 
diff -ru irssi-0.7.11/src/gui-gnome/gui-channels.c irssi-0.7.11-new/src/gui-gnome/gui-channels.c
--- irssi-0.7.11/src/gui-gnome/gui-channels.c	Sat May 15 15:47:08 1999
+++ irssi-0.7.11-new/src/gui-gnome/gui-channels.c	Sat Jun 12 17:51:30 1999
@@ -41,7 +41,7 @@
     GList *tmp;
 
     label = gtk_notebook_get_tab_label(GTK_NOTEBOOK(WINDOW_GUI(window)->parent->notebook),
-                                       WINDOW_GUI(window)->window);
+                                       WINDOW_GUI(window)->windowset->window);
     g_return_if_fail(label != NULL);
 
     str = g_string_new(NULL);
@@ -75,7 +75,7 @@
     if (channel->type == CHANNEL_TYPE_EMPTY)
         rec->servermenu = TRUE;
     if (channel->type == CHANNEL_TYPE_CHANNEL && toggle_show_nicklist)
-        gtk_widget_show(WINDOW_GUI(window)->nickscrollbox);
+        gtk_widget_show(WINDOW_GUI(window)->windowset->nickscrollbox);
 
     name = gui_channel_get_name(channel);
 
@@ -182,7 +182,7 @@
         /* create new window to use */
         window = !toggle_use_tabbed_windows ? NULL :
             cur_channel != NULL ? CHANNEL_PARENT(cur_channel) : NULL;
-        window = gui_window_create(window == NULL ? NULL : WINDOW_GUI(window)->parent);
+        window = gui_windowset_create(window == NULL ? NULL : WINDOW_GUI(window)->parent)->active->window;
     }
 
     gui_channel_init(window, channel);
@@ -230,7 +230,7 @@
         else
         {
             /* window is useless, destroy it. */
-            gui_window_destroy(window);
+            gui_window_view_destroy(WINDOW_GUI(window));
         }
     }
     return TRUE;
@@ -253,16 +253,16 @@
         if (channel->topic == NULL || *channel->topic == '\0')
         {
             /* No topic in channel */
-            gtk_entry_set_text(GTK_ENTRY(WINDOW_GUI(window)->topicentry), "");
+            gtk_entry_set_text(GTK_ENTRY(WINDOW_GUI(window)->windowset->topicentry), "");
         }
         else
         {
-            gtk_entry_set_text(GTK_ENTRY(WINDOW_GUI(window)->topicentry), channel->topic);
+            gtk_entry_set_text(GTK_ENTRY(WINDOW_GUI(window)->windowset->topicentry), channel->topic);
             g_string_sprintfa(tmp, " - %s", channel->topic);
         }
     }
 
-    if (window == WINDOW_GUI(window)->parent->active)
+    if (window == WINDOW_GUI(window)->parent->active->active->window)
         gtk_window_set_title(GTK_WINDOW(WINDOW_GUI(window)->parent->window), tmp->str);
     g_string_free(tmp, TRUE);
     return TRUE;
@@ -276,7 +276,7 @@
     g_return_if_fail(channel->server != NULL);
 
     str = g_strconcat(channel->server->nick, " / ", channel->server->tag, NULL);
-    gtk_label_set(GTK_LABEL(WINDOW_GUI(CHANNEL_PARENT(channel))->serverlabel), str);
+    gtk_label_set(GTK_LABEL(WINDOW_GUI(CHANNEL_PARENT(channel))->windowset->serverlabel), str);
     g_free(str);
 }
 
@@ -322,7 +322,7 @@
     window = CHANNEL_PARENT(channel);
     if (channel->type != CHANNEL_TYPE_CHANNEL || channel != window->active)
         return TRUE;
-    gui = WINDOW_GUI(window);
+    gui = WINDOW_GUI(window)->windowset;
 
     for (num = 0; num < 6; num++)
         gtk_object_set_data(GTK_OBJECT(gui->modebuttons[num]), "toggling", GINT_TO_POINTER(TRUE));
@@ -351,20 +351,21 @@
 
 static gboolean signal_channel_open(CHANNEL_REC *channel)
 {
-    WINDOW_REC *window;
+    GUI_WINDOW_REC *gui;
 
     g_return_val_if_fail(channel != NULL, FALSE);
 
-    window = CHANNEL_PARENT(channel);
-    if (WINDOW_GUI(window)->parent->active != window)
+    gui = WINDOW_GUI(CHANNEL_PARENT(channel))->windowset;
+
+    if (gui->parent->active->active->window != CHANNEL_PARENT(channel))
     {
         /* change to right window tab */
         gint page;
 
-        page = gtk_notebook_page_num(GTK_NOTEBOOK(WINDOW_GUI(window)->parent->notebook), WINDOW_GUI(window)->window);
-        gtk_notebook_set_page(GTK_NOTEBOOK(WINDOW_GUI(window)->parent->notebook), page);
+        page = gtk_notebook_page_num(GTK_NOTEBOOK(gui->parent->notebook), gui->window);
+        gtk_notebook_set_page(GTK_NOTEBOOK(gui->parent->notebook), page);
     }
-    gdk_window_show(WINDOW_GUI(window)->parent->window->window);
+    gdk_window_show(gui->parent->window->window);
 
     if (CHANNEL_PARENT(channel)->active != channel)
     {
diff -ru irssi-0.7.11/src/gui-gnome/gui-mainwindows.c irssi-0.7.11-new/src/gui-gnome/gui-mainwindows.c
--- irssi-0.7.11/src/gui-gnome/gui-mainwindows.c	Thu May 13 15:17:33 1999
+++ irssi-0.7.11-new/src/gui-gnome/gui-mainwindows.c	Sat Jun 12 17:31:42 1999
@@ -23,7 +23,7 @@
 
 GList *mainwindows;
 
-static WINDOW_REC *window_find_notebook_child(MAIN_WINDOW_REC *window, GtkWidget *child)
+static GUI_WINDOW_VIEW_REC *window_find_notebook_child(MAIN_WINDOW_REC *window, GtkWidget *child)
 {
     GList *tmp;
 
@@ -32,9 +32,9 @@
 
     for (tmp = g_list_first(window->children); tmp != NULL; tmp = tmp->next)
     {
-        WINDOW_REC *rec = tmp->data;
+        GUI_WINDOW_VIEW_REC *rec = tmp->data;
 
-        if (WINDOW_GUI(rec)->window == child) return rec;
+        if (rec->windowset->window == child) return rec;
     }
 
     return NULL;
@@ -57,9 +57,9 @@
 {
     g_return_val_if_fail(window != NULL, 0);
 
-    if (cur_channel != window->active->active)
+    if (cur_channel != window->active->active->window->active)
     {
-        cur_channel = window->active->active;
+        cur_channel = window->active->active->window->active;
         signal_emit("channel changed", 1, cur_channel);
         signal_emit("window focused", 1, window->active);
     }
@@ -70,7 +70,7 @@
 /* notebook signal: switch_page */
 static void sig_switch_page(GtkWidget *notebook, GtkNotebookPage *child, guint pagenum, MAIN_WINDOW_REC *window)
 {
-    WINDOW_REC *subwin;
+    GUI_WINDOW_VIEW_REC *subwin;
 
     g_return_if_fail(child != NULL);
     g_return_if_fail(window != NULL);
@@ -84,10 +84,10 @@
         return;
     }
 
-    window->active = subwin;
-    cur_channel = subwin->active;
+    window->active->active = subwin;
+    cur_channel = subwin->window->active;
     signal_emit("channel changed", 1, cur_channel);
-    signal_emit("window focused", 1, subwin);
+    signal_emit("window focused", 1, subwin->window);
 }
 
 static void window_change_page(WINDOW_REC *window)
@@ -96,7 +96,7 @@
 
     g_return_if_fail(window != NULL);
 
-    page = gtk_notebook_page_num(GTK_NOTEBOOK(WINDOW_GUI(window)->parent->notebook), WINDOW_GUI(window)->window);
+    page = gtk_notebook_page_num(GTK_NOTEBOOK(WINDOW_GUI(window)->parent->notebook), WINDOW_GUI(window)->windowset->window);
     gtk_notebook_set_page(GTK_NOTEBOOK(WINDOW_GUI(window)->parent->notebook), page);
 }
 
@@ -105,15 +105,15 @@
 /* signal: key pressed (in entry field) */
 static gint sig_keypress(GtkWidget *widget, GdkEventKey *event, MAIN_WINDOW_REC *window)
 {
-    GUI_WINDOW_REC *guiwin;
+    GUI_WINDOW_VIEW_REC *view;
     gchar *text;
 
     g_return_val_if_fail(event != NULL, 0);
     g_return_val_if_fail(window != NULL, 0);
 
-    guiwin = window->active == NULL ? NULL : WINDOW_GUI(window->active);
-    if (guiwin != NULL && guiwin->topicentry != NULL && GTK_WIDGET_HAS_FOCUS(guiwin->topicentry) &&
-        gtk_object_get_data(GTK_OBJECT(guiwin->topicentry), "editable"))
+    view = window->active == NULL ? NULL : window->active->active ;
+    if (view != NULL && view->windowset->topicentry != NULL && GTK_WIDGET_HAS_FOCUS(view->windowset->topicentry) &&
+        gtk_object_get_data(GTK_OBJECT(view->windowset->topicentry), "editable"))
     {
         /* trying to write topic, don't disturb it.. */
         return 0;
@@ -143,11 +143,11 @@
                 gint val;
 
 #ifdef HAVE_GNOME
-                if (guiwin->zvt)
-                    adj = ZVT_TERM(guiwin->text)->adjustment;
+                if (view->zvt)
+                    adj = ZVT_TERM(view->text)->adjustment;
                 else
 #endif
-                    adj = GTK_TEXT(guiwin->text)->vadj;
+                    adj = GTK_TEXT(view->text)->vadj;
                 val = adj->value - (adj->page_size/2);
                 gtk_adjustment_set_value(adj, val > 0 ? val : 0);
             }
@@ -161,11 +161,11 @@
                 gint val, max;
 
 #ifdef HAVE_GNOME
-                if (guiwin->zvt)
-                    adj = ZVT_TERM(guiwin->text)->adjustment;
+                if (view->zvt)
+                    adj = ZVT_TERM(view->text)->adjustment;
                 else
 #endif
-                    adj = GTK_TEXT(guiwin->text)->vadj;
+                    adj = GTK_TEXT(view->text)->vadj;
                 val = adj->value + (adj->page_size/2);
                 max = adj->upper - adj->lower - adj->page_size;
                 gtk_adjustment_set_value(adj, val <= max ? val : max);
@@ -179,7 +179,7 @@
                 gint pos;
 
                 pos = gtk_editable_get_position(GTK_EDITABLE(window->entry));
-                line = completion_line(window->active->active, gtk_entry_get_text(GTK_ENTRY(window->entry)), &pos);
+                line = completion_line(window->active->active->window->active, gtk_entry_get_text(GTK_ENTRY(window->entry)), &pos);
                 if (line != NULL)
                 {
                     gtk_entry_set_text(GTK_ENTRY(window->entry), line);
@@ -271,14 +271,14 @@
 
         ui_history_add(str, FALSE);
 
-        if (cur_channel != window->active->active)
+        if (cur_channel != window->active->active->window->active)
         {
             /* we get here at least when using click-to-focus and keyboard
                focus being in different window than mouse. Is there some
                event we could use instead of enter_notify_event to find out
                what window really has the focus? .. probably is, I'm too lazy
                to find out what it is .. */
-            cur_channel = window->active->active;
+            cur_channel = window->active->active->window->active;
             signal_emit("channel changed", 1, cur_channel);
         }
         signal_emit("send command", 3, str, cur_channel->server, cur_channel);
@@ -386,7 +403,7 @@
 
     window->destroying = TRUE;
     while (window->children != NULL)
-        gui_window_destroy(window->children->data);
+        gui_windowset_destroy(window->children->data);
     window->destroying = FALSE;
 
     gtk_widget_destroy(window->window);
diff -ru irssi-0.7.11/src/gui-gnome/gui-mainwindows.h irssi-0.7.11-new/src/gui-gnome/gui-mainwindows.h
--- irssi-0.7.11/src/gui-gnome/gui-mainwindows.h	Sun Apr 11 23:40:07 1999
+++ irssi-0.7.11-new/src/gui-gnome/gui-mainwindows.h	Sat Jun 12 17:23:49 1999
@@ -1,6 +1,9 @@
 #ifndef __GUI_MAINWINDOWS_H
 #define __GUI_MAINWINDOWS_H
 
+typedef struct _GUI_WINDOW_REC GUI_WINDOW_REC;
+typedef struct _GUI_WINDOW_VIEW_REC GUI_WINDOW_VIEW_REC;
+    
 typedef struct
 {
     GtkWidget *window;
@@ -17,7 +20,7 @@
     guint destroying:1;
 
     GList *children;
-    WINDOW_REC *active;
+    GUI_WINDOW_REC *active;
 }
 MAIN_WINDOW_REC;
 
diff -ru irssi-0.7.11/src/gui-gnome/gui-printtext.c irssi-0.7.11-new/src/gui-gnome/gui-printtext.c
--- irssi-0.7.11/src/gui-gnome/gui-printtext.c	Sun Jun  6 12:28:08 1999
+++ irssi-0.7.11-new/src/gui-gnome/gui-printtext.c	Mon Jun  7 18:44:44 1999
@@ -51,7 +51,7 @@
 /* Write text to ZVT window */
 static gboolean gui_printtext_zvt(CHANNEL_REC *channel, gint fgcolor, gint bgcolor, gint flags, gchar *str)
 {
-    GUI_WINDOW_REC *gui;
+    GUI_WINDOW_VIEW_REC *view;
     WINDOW_REC *window;
     gint fg, bg;
     GString *out;
@@ -59,7 +59,7 @@
     g_return_val_if_fail(str != NULL, FALSE);
 
     window = CHANNEL_PARENT(channel);
-    gui = WINDOW_GUI(window);
+    view = WINDOW_GUI(window);
 
     if (flags & PRINTFLAG_BEEP)
         gdk_beep();
@@ -75,7 +75,7 @@
     }
 
     if (*str == '\n')
-        zvt_term_feed(ZVT_TERM(gui->text), "\r", 1);
+        zvt_term_feed(ZVT_TERM(view->text), "\r", 1);
 
     out = g_string_new("\033[0;");
 
@@ -87,8 +87,8 @@
     g_string_sprintfa(out, "3%dm", ansitab[fg & 7]);
 
     g_string_append(out, str);
-    zvt_term_feed(ZVT_TERM(gui->text), out->str, out->len);
-    vt_cursor_state(gui->text, 0); /* hide the ugly cursor */
+    zvt_term_feed(ZVT_TERM(view->text), out->str, out->len);
+    vt_cursor_state(view->text, 0); /* hide the ugly cursor */
 
     g_string_free(out, TRUE);
 
@@ -99,7 +99,7 @@
 /* Write text to window */
 static gboolean gui_printtext(CHANNEL_REC *channel, gpointer fgcolor, gpointer bgcolor, gpointer flags, gchar *str)
 {
-    GUI_WINDOW_REC *gui;
+    GUI_WINDOW_VIEW_REC *view;
     WINDOW_REC *window;
     GdkColor *fg, *bg;
     GdkFont *font;
@@ -109,10 +109,10 @@
     g_return_val_if_fail(str != NULL, FALSE);
 
     window = CHANNEL_PARENT(channel);
-    gui = WINDOW_GUI(window);
+    view = WINDOW_GUI(window);
 
 #ifdef HAVE_GNOME
-    if (gui->zvt)
+    if (view->zvt)
     {
         /* Use ZVT widget */
         return gui_printtext_zvt(channel, GPOINTER_TO_INT(fgcolor),
@@ -126,13 +126,13 @@
        will happen.. (and this code even looks awful ...) */
     if (*str == '\n')
     {
-        gui->linepos = g_list_append(gui->linepos, GINT_TO_POINTER(gui->lastlinelen)+1);
-        gui->lastlinelen = 0;
+        view->linepos = g_list_append(view->linepos, GINT_TO_POINTER(view->lastlinelen)+1);
+        view->lastlinelen = 0;
     }
     else
-        gui->lastlinelen += strlen(str);
+        view->lastlinelen += strlen(str);
 
-    gtk_text_freeze(GTK_TEXT(gui->text));
+    gtk_text_freeze(GTK_TEXT(view->text));
     if (*str == '\n' && max_textwidget_lines > 0 &&
         max_textwidget_lines+block_remove_lines <= window->lines &&
         channel->type != CHANNEL_TYPE_SETUP)
@@ -143,15 +143,15 @@
         {
             GList *link;
 
-            link = g_list_first(gui->linepos);
+            link = g_list_first(view->linepos);
             len += GPOINTER_TO_INT(link->data);
-            gui->linepos = g_list_remove_link(gui->linepos, link);
+            view->linepos = g_list_remove_link(view->linepos, link);
             g_list_free_1(link);
             window->lines--;
         }
-        gtk_text_set_point(GTK_TEXT(gui->text), 0);
-        gtk_text_forward_delete(GTK_TEXT(gui->text), len);
-        gtk_text_set_point(GTK_TEXT(gui->text), gtk_text_get_length(GTK_TEXT(gui->text)));
+        gtk_text_set_point(GTK_TEXT(view->text), 0);
+        gtk_text_forward_delete(GTK_TEXT(view->text), len);
+        gtk_text_set_point(GTK_TEXT(view->text), gtk_text_get_length(GTK_TEXT(view->text)));
     }
 
     if (GPOINTER_TO_INT(flags) & PRINTFLAG_BOLD)
@@ -178,8 +178,8 @@
         fg = bg != NULL ? bg : &bg_color;
         bg = tmp;
     }
-    gtk_text_insert(GTK_TEXT(gui->text), font, fg, bg, str, -1);
-    gtk_text_thaw(GTK_TEXT(gui->text));
+    gtk_text_insert(GTK_TEXT(view->text), font, fg, bg, str, -1);
+    gtk_text_thaw(GTK_TEXT(view->text));
 
     if (sb_down) set_sb_down(window);
 
diff -ru irssi-0.7.11/src/gui-gnome/irssi.c irssi-0.7.11-new/src/gui-gnome/irssi.c
--- irssi-0.7.11/src/gui-gnome/irssi.c	Mon May 10 20:32:28 1999
+++ irssi-0.7.11-new/src/gui-gnome/irssi.c	Mon Jun  7 19:06:20 1999
@@ -38,7 +38,8 @@
 
     gui_printtext_init();
     mainwindows_init();
-    gui_windows_init();
+    gui_windowset_init();
+    gui_windows_view_init();
     gui_channels_init();
     gui_dcc_init();
     gui_events_init();
@@ -86,7 +87,8 @@
     gui_events_deinit();
     gui_server_deinit();
     mainwindows_deinit();
-    gui_windows_deinit();
+    gui_windows_view_deinit();
+    gui_windowset_deinit();
     gui_channels_deinit(); /* channels after mainwindows_deinit()! */
     gui_printtext_deinit();
     setup_deinit();
diff -ru irssi-0.7.11/src/gui-gnome/irssi.h irssi-0.7.11-new/src/gui-gnome/irssi.h
--- irssi-0.7.11/src/gui-gnome/irssi.h	Mon May 10 20:24:46 1999
+++ irssi-0.7.11-new/src/gui-gnome/irssi.h	Mon Jun  7 18:34:03 1999
@@ -35,7 +35,8 @@
 #include "setup.h"
 #include "gui-mainwindows.h"
 #include "gui-channels.h"
-#include "gui-windows.h"
+#include "gui-windowset.h"
+#include "gui-windows-view.h"
 
 #include "channels-newdata.h"
 #include "dialogs.h"
diff -ru irssi-0.7.11/src/gui-gnome/setup-appearance.c irssi-0.7.11-new/src/gui-gnome/setup-appearance.c
--- irssi-0.7.11/src/gui-gnome/setup-appearance.c	Sun Jun  6 20:10:05 1999
+++ irssi-0.7.11-new/src/gui-gnome/setup-appearance.c	Mon Jun  7 19:07:22 1999
@@ -49,16 +49,16 @@
 
 static gchar *temp_font_name;
 
-static void set_window_bg(GUI_WINDOW_REC *window)
+static void set_window_bg(GUI_WINDOW_VIEW_REC *view)
 {
     GtkStyle *style;
 
-    g_return_if_fail(window != NULL);
+    g_return_if_fail(view != NULL);
 
-    style = gtk_style_copy(window->text->style);
+    style = gtk_style_copy(view->text->style);
     gtk_style_ref(style);
     style->base[0] = temp_bg_color;
-    gtk_widget_set_style(window->text, style);
+    gtk_widget_set_style(view->text, style);
     gtk_style_unref(style);
 
 }
@@ -71,14 +71,14 @@
     static gboolean old_timestamps;
     static gint oldlines, len;
 
-    GUI_WINDOW_REC *guiwin;
+    GUI_WINDOW_VIEW_REC *view;
     WINDOW_REC *window;
     gint n;
 
     g_return_if_fail(channel != NULL);
 
     window = CHANNEL_PARENT(channel);
-    guiwin = WINDOW_GUI(window);
+    view = WINDOW_GUI(window);
 
     if (init)
     {
@@ -90,16 +90,16 @@
         old_timestamps = toggle_show_timestamps;
         toggle_show_timestamps = FALSE;
 
-        set_window_bg(guiwin);
+        set_window_bg(view);
 
         gui_printtext_configure();
 
-        oldval = GTK_TEXT(guiwin->text)->vadj->value;
+        oldval = GTK_TEXT(view->text)->vadj->value;
         oldlines = window->lines;
-        len = gtk_text_get_length(GTK_TEXT(guiwin->text));
+        len = gtk_text_get_length(GTK_TEXT(view->text));
 
-        gtk_text_freeze(GTK_TEXT(guiwin->text));
-        gtk_text_set_point(GTK_TEXT(guiwin->text), len);
+        gtk_text_freeze(GTK_TEXT(view->text));
+        gtk_text_set_point(GTK_TEXT(view->text), len);
     }
     else
     {
@@ -108,10 +108,10 @@
         window->lines = oldlines;
 
         /*FIXME: this doesn't remove the lines from linelen list*/
-        gtk_text_set_point(GTK_TEXT(guiwin->text), 0);
-        gtk_text_forward_delete(GTK_TEXT(guiwin->text), len);
-        gtk_text_thaw(GTK_TEXT(guiwin->text));
-        gtk_adjustment_set_value(GTK_TEXT(guiwin->text)->vadj, oldval);
+        gtk_text_set_point(GTK_TEXT(view->text), 0);
+        gtk_text_forward_delete(GTK_TEXT(view->text), len);
+        gtk_text_thaw(GTK_TEXT(view->text));
+        gtk_adjustment_set_value(GTK_TEXT(view->text)->vadj, oldval);
 
         bg_color = old_bg_color;
         memcpy(setup_colors, old_colors, sizeof(setup_colors));
diff -ru irssi-0.7.11/src/gui-gnome/snapshot.c irssi-0.7.11-new/src/gui-gnome/snapshot.c
--- irssi-0.7.11/src/gui-gnome/snapshot.c	Thu May 13 16:03:54 1999
+++ irssi-0.7.11-new/src/gui-gnome/snapshot.c	Mon Jun  7 19:08:17 1999
@@ -24,25 +24,25 @@
 
 static void snapshot_show(WINDOW_REC *window)
 {
-    GUI_WINDOW_REC *gui;
+    GUI_WINDOW_VIEW_REC *view;
     GtkWidget *scrollbox;
     GtkAdjustment *adj;
     gint x, y, xsize, ysize;
 
     g_return_if_fail(window != NULL);
 
-    gui = WINDOW_GUI(window);
+    view = WINDOW_GUI(window);
     gdk_window_get_pointer (NULL, &x, &y, NULL);
 
-    gui->snapshot = gtk_window_new(GTK_WINDOW_POPUP);
+    view->snapshot = gtk_window_new(GTK_WINDOW_POPUP);
 
     scrollbox = gtk_scrolled_window_new(NULL, NULL);
     gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrollbox),
                                    GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
-    gtk_container_add(GTK_CONTAINER(gui->snapshot), scrollbox);
+    gtk_container_add(GTK_CONTAINER(view->snapshot), scrollbox);
 
-    xsize = gui->text->allocation.width;
-    ysize = gui->text->allocation.height;
+    xsize = view->text->allocation.width;
+    ysize = view->text->allocation.height;
 
     if (xsize <= 1) xsize = gdk_screen_width()/2;
     if (ysize <= 1) ysize = gdk_screen_height()*2/5;
@@ -58,18 +58,18 @@
     else
         y += 5;
 
-    gtk_widget_set_uposition(gui->snapshot, x, y);
+    gtk_widget_set_uposition(view->snapshot, x, y);
 
-    gtk_object_set_data(GTK_OBJECT(gui->text), "parent", gui->text->parent);
-    gtk_widget_reparent(gui->text, scrollbox);
-    gtk_widget_show_all(gui->snapshot);
+    gtk_object_set_data(GTK_OBJECT(view->text), "parent", view->text->parent);
+    gtk_widget_reparent(view->text, scrollbox);
+    gtk_widget_show_all(view->snapshot);
 
 #ifdef HAVE_GNOME
-    if (gui->zvt)
-        adj = ZVT_TERM(gui->text)->adjustment;
+    if (view->zvt)
+        adj = ZVT_TERM(view->text)->adjustment;
     else
 #endif
-        adj = GTK_TEXT(gui->text)->vadj;
+        adj = GTK_TEXT(view->text)->vadj;
     gtk_adjustment_set_value(adj, adj->upper - adj->lower - adj->page_size);
 
     signal_emit("window focused", 1, window);
@@ -77,18 +77,18 @@
 
 static void snapshot_hide(WINDOW_REC *window)
 {
-    GUI_WINDOW_REC *gui;
+    GUI_WINDOW_VIEW_REC *view;
     GtkWidget *parent;
 
     g_return_if_fail(window != NULL);
 
-    gui = WINDOW_GUI(window);
-    parent = gtk_object_get_data(GTK_OBJECT(gui->text), "parent");
+    view = WINDOW_GUI(window);
+    parent = gtk_object_get_data(GTK_OBJECT(view->text), "parent");
     g_return_if_fail(parent != NULL);
 
-    gtk_widget_reparent(gui->text, parent);
-    gtk_widget_destroy(gui->snapshot);
-    gui->snapshot = NULL;
+    gtk_widget_reparent(view->text, parent);
+    gtk_widget_destroy(view->snapshot);
+    view->snapshot = NULL;
 
     signal_emit("window focused", 1, ((MAIN_WINDOW_REC *) mainwindows->data)->active);
 }
diff -ru irssi-0.7.11/src/gui-gnome/window-menus.c irssi-0.7.11-new/src/gui-gnome/window-menus.c
--- irssi-0.7.11/src/gui-gnome/window-menus.c	Sat May 15 22:08:20 1999
+++ irssi-0.7.11-new/src/gui-gnome/window-menus.c	Sat Jun 12 17:34:53 1999
@@ -280,7 +280,7 @@
     window = gtk_object_get_data(GTK_OBJECT(menuitem->parent), "window");
     g_return_if_fail(window != NULL);
 
-    window->active->active->server = server;
+    window->active->active->window->active->server = server;
     signal_emit("window server changed", 1, window->active);
 }
 
@@ -330,7 +330,7 @@
         gtk_menu_append(GTK_MENU(menu), menuitem);
 
         if (window->active != NULL)
-            gtk_option_menu_set_history(GTK_OPTION_MENU(window->servermenu), g_list_index(servers, window->active->active->server));
+            gtk_option_menu_set_history(GTK_OPTION_MENU(window->servermenu), g_list_index(servers, window->active->active->window->active->server));
     }
 
     return TRUE;
@@ -381,19 +381,19 @@
 
 static void menu_chan_toggle_nicklist(GtkWidget *menuitem, CHANNEL_REC *channel)
 {
-    GUI_WINDOW_REC *window;
+    GtkWidget *nickscrollbox;
 
     g_return_if_fail(menuitem != NULL);
     if (channel == NULL) return;
 
-    window = WINDOW_GUI(CHANNEL_PARENT(channel));
-    if (window->nickscrollbox == NULL)
+    nickscrollbox = WINDOW_GUI(CHANNEL_PARENT(channel))->windowset->nickscrollbox;
+    if (nickscrollbox == NULL)
         return; /* this function was called from window_create().. */
 
     if (GTK_CHECK_MENU_ITEM(menuitem)->active)
-        gtk_widget_show(window->nickscrollbox);
+        gtk_widget_show(nickscrollbox);
     else
-        gtk_widget_hide(window->nickscrollbox);
+        gtk_widget_hide(nickscrollbox);
 }
 
 static void menu_query_close(GtkWidget *menuitem, CHANNEL_REC *channel)
@@ -433,7 +433,7 @@
     toggling = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(menuitem), "toggling"));
     if (toggling) return;
 
-    server = window->active->active->server;
+    server = window->active->active->window->active->server;
     gtk_object_set_data(GTK_OBJECT(menuitem), "toggling", GINT_TO_POINTER(TRUE));
     gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menuitem),
                                   server == NULL ? FALSE : server->usermode_away);
@@ -478,9 +478,9 @@
     g_return_if_fail(menuitem != NULL);
     if (window == NULL) return;
 
-    server = window->active->active->server;
+    server = window->active->active->window->active->server;
     usermode_set(menuitem, 'i', server == NULL ? FALSE :
-                 server->usermode_invisible, window->active->active);
+                 server->usermode_invisible, window->active->active->window->active);
 }
 
 static void menu_usermode_wallops(GtkWidget *menuitem, MAIN_WINDOW_REC *window)
@@ -490,9 +490,9 @@
     g_return_if_fail(menuitem != NULL);
     if (window == NULL) return;
 
-    server = window->active->active->server;
+    server = window->active->active->window->active->server;
     usermode_set(menuitem, 'w', server == NULL ? FALSE :
-                 server->usermode_wallops, window->active->active);
+                 server->usermode_wallops, window->active->active->window->active);
 }
 
 static void menu_usermode_snotes(GtkWidget *menuitem, MAIN_WINDOW_REC *window)
@@ -502,19 +502,19 @@
     g_return_if_fail(menuitem != NULL);
     if (window == NULL) return;
 
-    server = window->active->active->server;
+    server = window->active->active->window->active->server;
     usermode_set(menuitem, 's', server == NULL ? FALSE :
-                 server->usermode_servernotes, window->active->active);
+                 server->usermode_servernotes, window->active->active->window->active);
 }
 
 static void menu_dcc_chat(GtkWidget *menuitem, MAIN_WINDOW_REC *window)
 {
-    gui_dcc_chat(window->active->active != NULL ? window->active->active->server : window->active->active->server);
+    gui_dcc_chat(window->active->active != NULL ? window->active->active->window->active->server : window->active->active->window->active->server);
 }
 
 static void menu_dcc_send(GtkWidget *menuitem, MAIN_WINDOW_REC *window)
 {
-    gui_dcc_send(window->active->active != NULL ? window->active->active->server : window->active->active->server, NULL, NULL);
+    gui_dcc_send(window->active->active != NULL ? window->active->active->window->active->server : window->active->active->window->active->server, NULL, NULL);
 }
 
 static void menu_window_new(GtkWidget *menuitem, MAIN_WINDOW_REC *window)
@@ -526,7 +526,7 @@
 
     old = toggle_use_tabbed_windows;
     toggle_use_tabbed_windows = FALSE;
-    channel_create(window->active->active->server, _("(empty)"), CHANNEL_TYPE_EMPTY);
+    channel_create(window->active->active->window->active->server, _("(empty)"), CHANNEL_TYPE_EMPTY);
     toggle_use_tabbed_windows = old;
 }
 
@@ -539,7 +539,7 @@
 
     old = toggle_use_tabbed_windows;
     toggle_use_tabbed_windows = TRUE;
-    channel_create(window->active->active->server, _("(empty)"), CHANNEL_TYPE_EMPTY);
+    channel_create(window->active->active->window->active->server, _("(empty)"), CHANNEL_TYPE_EMPTY);
     toggle_use_tabbed_windows = old;
 }
 
@@ -554,7 +554,7 @@
     toggling = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(menuitem), "toggling"));
     if (toggling) return;
 
-    gui = CHANNEL_GUI(window->active->active);
+    gui = CHANNEL_GUI(window->active->active->window->active);
     gui->autoraise = GTK_CHECK_MENU_ITEM(menuitem)->active; /* FIXME: better way for this? gtk needs a function for this.. */
 
     gtk_object_set_data(GTK_OBJECT(menuitem), "toggling", GINT_TO_POINTER(TRUE));
@@ -567,7 +567,7 @@
     g_return_if_fail(menuitem != NULL);
     if (window == NULL) return;
 
-    gui_window_destroy(window->active);
+    gui_windowset_destroy(window->active);
 }
 
 static void menu_settings_preferences(void)
@@ -657,7 +657,7 @@
     switch (channel->type)
     {
         case CHANNEL_TYPE_CHANNEL:
-            gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(channel_submenu[2].widget), GTK_WIDGET_VISIBLE(WINDOW_GUI(CHANNEL_PARENT(channel))->nickscrollbox));
+            gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(channel_submenu[2].widget), GTK_WIDGET_VISIBLE(WINDOW_GUI(CHANNEL_PARENT(channel))->windowset->nickscrollbox));
             break;
 
         case CHANNEL_TYPE_QUERY:
Only in irssi-0.7.11-new/src/gui-gnome: window-menus.o
diff -ru irssi-0.7.11/src/gui-gnome/window-nicklist.c irssi-0.7.11-new/src/gui-gnome/window-nicklist.c
--- irssi-0.7.11/src/gui-gnome/window-nicklist.c	Thu May 13 15:15:09 1999
+++ irssi-0.7.11-new/src/gui-gnome/window-nicklist.c	Mon Jun  7 19:11:02 1999
@@ -93,7 +93,7 @@
     g_return_if_fail(nick != NULL);
 
     if (CHANNEL_PARENT(channel)->active != channel) return;
-    gui = WINDOW_GUI(CHANNEL_PARENT(channel));
+    gui = WINDOW_GUI(CHANNEL_PARENT(channel))->windowset;
 
     list = GTK_CLIST(gui->nicklist)->row_list;
     for (row = 0; list != NULL; row++, list = list->next)
@@ -130,9 +130,9 @@
     window = CHANNEL_PARENT(channel);
     if (window->active != channel) return;
 
-    row = gtk_clist_find_row_from_data(GTK_CLIST(WINDOW_GUI(window)->nicklist), nick);
+    row = gtk_clist_find_row_from_data(GTK_CLIST(WINDOW_GUI(window)->windowset->nicklist), nick);
     if (row != -1)
-        gtk_clist_remove(GTK_CLIST(WINDOW_GUI(window)->nicklist), row);
+        gtk_clist_remove(GTK_CLIST(WINDOW_GUI(window)->windowset->nicklist), row);
 }
 
 void window_nicklist_redraw(CHANNEL_REC *channel)
@@ -141,7 +141,7 @@
     GList *tmp;
 
     if (CHANNEL_PARENT(channel)->active != channel) return;
-    gui = WINDOW_GUI(CHANNEL_PARENT(channel));
+    gui = WINDOW_GUI(CHANNEL_PARENT(channel))->windowset;
 
     gtk_clist_freeze(GTK_CLIST(gui->nicklist));
     gtk_clist_clear(GTK_CLIST(gui->nicklist));
@@ -443,7 +443,7 @@
     g_return_val_if_fail(window != NULL, FALSE);
 
     /* create op and voice pixmaps */
-    gui = WINDOW_GUI(window);
+    gui = WINDOW_GUI(window)->windowset;
     gtk_widget_realize(gui->window);
     gui->op_pixmap = gdk_pixmap_create_from_xpm_d(gui->window->window, &gui->op_mask, NULL, op_xpm);
     gui->voice_pixmap = gdk_pixmap_create_from_xpm_d(gui->window->window, &gui->voice_mask, NULL, voice_xpm);
@@ -477,7 +477,7 @@
 
     chanrec = channel_find(server, channel);
     if (chanrec != NULL && !server->names_coming)
-        gtk_clist_freeze(GTK_CLIST(WINDOW_GUI(CHANNEL_PARENT(chanrec))->nicklist));
+        gtk_clist_freeze(GTK_CLIST(WINDOW_GUI(CHANNEL_PARENT(chanrec))->windowset->nicklist));
 
     g_free(params);
     return TRUE;
@@ -494,7 +494,7 @@
 
     chanrec = channel_find(server, channel);
     if (chanrec != NULL)
-        gtk_clist_thaw(GTK_CLIST(WINDOW_GUI(CHANNEL_PARENT(chanrec))->nicklist));
+        gtk_clist_thaw(GTK_CLIST(WINDOW_GUI(CHANNEL_PARENT(chanrec))->windowset->nicklist));
 
     g_free(params);
     return TRUE;
diff -Nru irssi-0.7.11/src/gui-gnome/gui-windowset.c irssi-0.7.11-new/src/gui-gnome/gui-windowset.c
--- irssi-0.7.11/src/gui-gnome/gui-windowset.c	Thu Jan  1 02:00:00 1970
+++ irssi-0.7.11-new/src/gui-gnome/gui-windowset.c	Sat Jun 12 17:39:10 1999
@@ -0,0 +1,385 @@
+/*
+ gui-windowset.c : irssi
+
+    Copyright (C) 1999 Timo Sirainen
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "irssi.h"
+
+static gchar mode_flags[] = "spmint";
+static gchar *mode_tooltips[] =
+{
+    N_("Secret"),
+    N_("Private"),
+    N_("Moderated"),
+    N_("Joining needs an invitation"),
+    N_("No external messages"),
+    N_("Only operators can change the topic")
+};
+
+static gint sig_topicentry_press(GtkWidget *entry, GdkEventButton *event)
+{
+    gboolean editable;
+
+    g_return_val_if_fail(entry != NULL, 0);
+    g_return_val_if_fail(event != NULL, 0);
+
+    if (event->type == GDK_2BUTTON_PRESS)
+    {
+        editable = !(gboolean) GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(entry), "editable"));
+        gtk_object_set_data(GTK_OBJECT(entry), "editable", GINT_TO_POINTER((gint) editable));
+        gtk_entry_set_editable(GTK_ENTRY(entry), editable);
+    }
+
+    return 0;
+}
+
+static void sig_topicentry_activated(GtkWidget *entry, WINDOW_REC *window)
+{
+    CHANNEL_REC *channel;
+
+    g_return_if_fail(entry != NULL);
+    g_return_if_fail(window != NULL);
+
+    channel = window->active;
+    if (channel == NULL || (!channel->chanop && channel->mode_optopic))
+    {
+        /* can't change topic. */
+        gtk_entry_set_text(GTK_ENTRY(entry),
+                           (channel == NULL || channel->topic == NULL) ?
+                           "" : channel->topic);
+        return;
+    }
+
+    signal_emit("command topic", 3, gtk_entry_get_text(GTK_ENTRY(entry)),
+                window->active->server, window->active);
+}
+
+static void sig_modebutton_toggled(GtkToggleButton *button, gint mode)
+{
+    WINDOW_REC *window;
+    NICK_REC *nick;
+    GString *str;
+
+    g_return_if_fail(button != NULL);
+    if (gtk_object_get_data(GTK_OBJECT(button), "toggling")) return;
+
+    window = gtk_object_get_data(GTK_OBJECT(button), "window");
+    g_return_if_fail(window->active != NULL);
+
+    nick = nicklist_find(window->active, window->active->server->nick);
+    if (!window->active->chanop)
+    {
+        /* can't change mode */
+        gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(TRUE));
+        gtk_toggle_button_set_active(button, !button->active);
+        gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(FALSE));
+        return;
+    }
+
+    str = g_string_new(NULL);
+    g_string_sprintf(str, "* %c%c", button->active ? '+' : '-', mode_flags[mode]);
+
+    gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(TRUE));
+    signal_emit("command mode", 3, str->str, window->active->server, window->active);
+    g_string_free(str, TRUE);
+    gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(FALSE));
+}
+
+GUI_WINDOW_REC *gui_windowset_create(MAIN_WINDOW_REC *parent)
+{
+    WINDOW_REC *rec;
+    GUI_WINDOW_REC *gui;
+    GUI_WINDOW_VIEW_REC *view;
+    GtkWidget *hbox, *label;
+    GtkTooltips *tooltips;
+    gint num;
+
+    if (parent == NULL) parent = mainwindow_create();
+
+    rec = ui_window_create();
+    g_return_val_if_fail(rec != NULL, NULL);
+
+    gui = g_new0(GUI_WINDOW_REC, 1);
+    gui->parent = parent;
+
+    if (parent->children == NULL) parent->active = gui;
+    parent->children = g_list_append(parent->children, gui);
+
+    gui->window = gtk_vbox_new(FALSE, 2);
+    gtk_container_border_width(GTK_CONTAINER(gui->window), 2);
+
+    /* Add channel topic and modes */
+    gui->channelwidget = gtk_hbox_new(FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(gui->window), gui->channelwidget, FALSE, FALSE, 0);
+
+    gui->serverlabel = gtk_label_new("");
+    gtk_box_pack_start(GTK_BOX(gui->channelwidget), gui->serverlabel, FALSE, FALSE, 0);
+
+    gui->topicentry = gtk_entry_new();
+    gtk_entry_set_editable(GTK_ENTRY(gui->topicentry), FALSE);
+    gtk_signal_connect(GTK_OBJECT(gui->topicentry), "button_press_event",
+                       GTK_SIGNAL_FUNC(sig_topicentry_press), rec);
+    gtk_signal_connect(GTK_OBJECT(gui->topicentry), "activate",
+                       GTK_SIGNAL_FUNC(sig_topicentry_activated), rec);
+    gtk_box_pack_start(GTK_BOX(gui->channelwidget), gui->topicentry, TRUE, TRUE, 3);
+
+    tooltips = gtk_tooltips_new();
+
+    for (num = 0; num < 6; num++)
+    {
+        gchar str[2];
+
+        str[0] = toupper(mode_flags[num]); str[1] = '\0';
+        gui->modebuttons[num] = gtk_toggle_button_new_with_label(str);
+        gtk_tooltips_set_tip(tooltips, gui->modebuttons[num], mode_tooltips[num], NULL);
+        gtk_widget_set_usize(gui->modebuttons[num], 20, -1);
+        gtk_object_set_data(GTK_OBJECT(gui->modebuttons[num]), "window", rec);
+        gtk_signal_connect(GTK_OBJECT(gui->modebuttons[num]), "toggled",
+                           GTK_SIGNAL_FUNC(sig_modebutton_toggled), GINT_TO_POINTER(num));
+        gtk_box_pack_start(GTK_BOX(gui->channelwidget), gui->modebuttons[num], FALSE, FALSE, 0);
+    }
+
+    /* create view for window */
+    hbox = gtk_hbox_new(FALSE, 3);
+    gtk_box_pack_start(GTK_BOX(gui->window), hbox, TRUE, TRUE, 0);
+
+    view = gui_window_view_create(rec, gui, hbox);
+    gui->active = view;
+
+    gtk_widget_show_all(gui->window);
+
+    /* Add nick list */
+    gui->nickscrollbox = gtk_scrolled_window_new(NULL, NULL);
+    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gui->nickscrollbox),
+                                   GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+    gtk_box_pack_start(GTK_BOX(hbox), gui->nickscrollbox, FALSE, FALSE, 0);
+
+    gui->nicklist = gtk_clist_new(1);
+    gtk_container_add(GTK_CONTAINER(gui->nickscrollbox), gui->nicklist);
+    gtk_widget_show(gui->nicklist);
+
+    gtk_widget_set_usize(gui->nickscrollbox, 120, -1);
+
+    label = gtk_label_new(_("(none)"));
+    gtk_widget_show(label);
+
+    if (g_list_first(parent->children)->next == NULL)
+    {
+        /* only one child, don't show the notebook tabs.. */
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(parent->notebook), FALSE);
+        gtk_notebook_set_show_border(GTK_NOTEBOOK(parent->notebook), FALSE);
+    }
+    else if (g_list_first(parent->children)->next->next == NULL)
+    {
+        /* two children, show the notebook tabs.. */
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(parent->notebook), TRUE);
+        gtk_notebook_set_show_border(GTK_NOTEBOOK(parent->notebook), TRUE);
+    }
+
+    gtk_notebook_append_page(GTK_NOTEBOOK(parent->notebook), gui->window, label);
+
+    gtk_widget_hide(gui->channelwidget);
+
+    signal_emit("gui window created", 1, rec);
+    return gui;
+}
+
+void gui_windowset_destroy(GUI_WINDOW_REC *window)
+{
+    MAIN_WINDOW_REC *parent;
+    gint page;
+
+    g_return_if_fail(window != NULL);
+
+    if (window->destroying) return;
+
+    parent = window->parent;
+    parent->children = g_list_remove(parent->children, window);
+
+    signal_emit("gui window destroyed", 1, window);
+
+    window->destroying = TRUE;
+
+    page = gtk_notebook_page_num(GTK_NOTEBOOK(parent->notebook), window->window);
+    gtk_notebook_remove_page(GTK_NOTEBOOK(parent->notebook), page);
+
+    while (window->views != NULL)
+        gui_window_view_destroy(window->views->data);
+
+    g_free(window);
+
+    if (parent->children == NULL)
+        mainwindow_destroy(parent);
+    else if (g_list_length(parent->children) == 1)
+    {
+        /* only one child left, hide the notebook tabs.. */
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(parent->notebook), FALSE);
+        gtk_notebook_set_show_border(GTK_NOTEBOOK(parent->notebook), FALSE);
+    }
+}
+
+static gboolean gui_window_server_changed(WINDOW_REC *window)
+{
+    MAIN_WINDOW_REC *parent;
+    SERVER_REC *server;
+    gint num;
+
+    g_return_val_if_fail(window != NULL, FALSE);
+
+    parent = WINDOW_GUI(window)->parent;
+    server = window->active->server;
+
+    if (parent->usermodes[0] == NULL) return TRUE;
+
+    for (num = 0; num < 4; num++)
+        gtk_object_set_data(GTK_OBJECT(parent->usermodes[num]), "toggling", GINT_TO_POINTER(TRUE));
+
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[0]),
+                                  server == NULL ? FALSE : server->usermode_away);
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[1]),
+                                  server == NULL ? FALSE : server->usermode_invisible);
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[2]),
+                                  server == NULL ? FALSE : server->usermode_wallops);
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[3]),
+                                  server == NULL ? FALSE : server->usermode_servernotes);
+
+    for (num = 0; num < 4; num++)
+        gtk_object_set_data(GTK_OBJECT(parent->usermodes[num]), "toggling", GINT_TO_POINTER(FALSE));
+
+    return TRUE;
+}
+
+static gboolean gui_windows_usermode_changed(SERVER_REC *server)
+{
+    GList *winlist;
+
+    for (winlist = g_list_first(mainwindows); winlist != NULL; winlist = winlist->next)
+    {
+        MAIN_WINDOW_REC *rec = winlist->data;
+
+        if (server == rec->active->active->window->active->server)
+            signal_emit("window server changed", 1, rec->active);
+    }
+
+    return TRUE;
+}
+
+static gboolean signal_window_focused(WINDOW_REC *window)
+{
+    MAIN_WINDOW_REC *mainwindow;
+    GUI_WINDOW_REC *gui;
+    CHANNEL_REC *channel;
+
+    g_return_val_if_fail(window != NULL, FALSE);
+
+    mainwindow = WINDOW_GUI(window)->parent;
+    channel = window->active;
+ 
+    gui = mainwindow->active;
+
+    /* remove old extra menus */
+    if (mainwindow->extramenu != NULL)
+    {
+        window_menus_remove(mainwindow, mainwindow->extramenu);
+        g_free(mainwindow->extramenu);
+        mainwindow->extramenu = NULL;
+    }
+    if (channel == NULL) return TRUE;
+
+    if (channel->type == CHANNEL_TYPE_CHANNEL)
+    {
+        /* Add channel menu */
+        mainwindow->extramenu = g_strdup(channel_menu[0].label);
+        window_menus_insert(mainwindow, NULL, channel_menu, channel);
+        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(channel_submenu[2].widget),
+                                      GTK_WIDGET_VISIBLE(gui->nickscrollbox));
+        gtk_widget_show(gui->channelwidget);
+    }
+    else
+    {
+        gtk_widget_hide(gui->nickscrollbox);
+        gtk_widget_hide(gui->channelwidget);
+        if (channel->type == CHANNEL_TYPE_QUERY)
+        {
+            /* Add query menu */
+            mainwindow->extramenu = g_strdup(query_menu[0].label);
+            window_menus_insert(mainwindow, NULL, query_menu, channel);
+        }
+    }
+
+    if (CHANNEL_GUI(channel)->servermenu)
+    {
+        /* change server selection */
+        gtk_option_menu_set_history(GTK_OPTION_MENU(mainwindow->servermenu),
+                                    g_list_index(servers, channel->server));
+        gtk_widget_show(mainwindow->servermenu);
+    }
+    else
+        gtk_widget_hide(mainwindow->servermenu);
+
+    /* draw title bar */
+    signal_emit("channel topic changed", 1, window->active);
+
+    return TRUE;
+}
+
+static gboolean gui_server_looking(SERVER_REC *server)
+{
+    GList *tmp, *sub;
+
+    g_return_val_if_fail(server != NULL, FALSE);
+
+    /* try to keep some server assigned to server menus.. */
+    for (tmp = g_list_first(windows); tmp != NULL; tmp = tmp->next)
+    {
+        WINDOW_REC *win = tmp->data;
+        gboolean changed;
+
+        changed = FALSE;
+        for (sub = g_list_first(win->channels); sub != NULL; sub = sub->next)
+        {
+            CHANNEL_REC *chan = sub->data;
+
+            if (chan->server == NULL)
+            {
+                chan->server = server;
+                if (!changed)
+                    signal_emit("window server changed", 1, win);
+                changed = TRUE;
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+void gui_windowset_init(void)
+{
+    signal_add("user mode changed", (SIGNAL_FUNC) gui_windows_usermode_changed);
+    signal_add("window server changed", (SIGNAL_FUNC) gui_window_server_changed);
+    signal_add("window focused", (SIGNAL_FUNC) signal_window_focused);
+    signal_add("server looking", (SIGNAL_FUNC) gui_server_looking);
+}
+
+void gui_windowset_deinit(void)
+{
+    signal_remove("user mode changed", (SIGNAL_FUNC) gui_windows_usermode_changed);
+    signal_remove("window server changed", (SIGNAL_FUNC) gui_window_server_changed);
+    signal_remove("window focused", (SIGNAL_FUNC) signal_window_focused);
+    signal_remove("server looking", (SIGNAL_FUNC) gui_server_looking);
+}
diff -Nru irssi-0.7.11/src/gui-gnome/gui-windowset.h irssi-0.7.11-new/src/gui-gnome/gui-windowset.h
--- irssi-0.7.11/src/gui-gnome/gui-windowset.h	Thu Jan  1 02:00:00 1970
+++ irssi-0.7.11-new/src/gui-gnome/gui-windowset.h	Sat Jun 12 17:22:55 1999
@@ -0,0 +1,32 @@
+#ifndef __GUI_WINDOWSET_H
+#define __GUI_WINDOWSET_H
+
+struct _GUI_WINDOW_REC
+{
+    MAIN_WINDOW_REC *parent;
+
+    GtkWidget *window;
+    GList *views;
+    GUI_WINDOW_VIEW_REC *active;
+
+    GtkWidget *channelwidget;
+    GtkWidget *serverlabel;
+    GtkWidget *topicentry;
+    GtkWidget *modebuttons[6];
+
+    /* nicklist */
+    GtkWidget *nickscrollbox;
+    GtkWidget *nicklist;
+    GdkPixmap *op_pixmap, *voice_pixmap;
+    GdkBitmap *op_mask, *voice_mask;
+
+    gboolean destroying;
+};
+
+void gui_windowset_init(void);
+void gui_windowset_deinit(void);
+
+GUI_WINDOW_REC *gui_windowset_create(MAIN_WINDOW_REC *parent);
+void gui_windowset_destroy(GUI_WINDOW_REC *window);
+
+#endif
diff -Nru irssi-0.7.11/src/gui-gnome/gui-windows-view.c irssi-0.7.11-new/src/gui-gnome/gui-windows-view.c
--- irssi-0.7.11/src/gui-gnome/gui-windows-view.c	Thu Jan  1 02:00:00 1970
+++ irssi-0.7.11-new/src/gui-gnome/gui-windows-view.c	Sat Jun 12 17:16:29 1999
@@ -0,0 +1,454 @@
+/*
+ gui-windows-view.c : irssi
+
+    Copyright (C) 1999 Timo Sirainen
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "irssi.h"
+
+#define iswordcut(a) (isspace((gint) a) || \
+    (a) == '\n' || (a) == '\0' || (a) == '"' || \
+    (a) == '(' || (a) == ')' || (a) == '[' || (a) == ']' || \
+    (a) == '<' || (a) == '>')
+
+#define URL_MAX_LENGTH 200 /*FIXME: no max. limits*/
+
+GList *window_views;
+
+void gui_window_view_set_background_pixmap(GUI_WINDOW_VIEW_REC *view, gchar *path)
+{
+    GtkStyle *style;
+    GdkPixmap *pixmap;
+    GdkBitmap *mask;
+#if defined (HAVE_IMLIB) || defined (HAVE_GNOME)
+    GdkImlibImage *img;
+#endif
+
+    g_return_if_fail(view != NULL);
+    g_return_if_fail(path != NULL);
+
+    if (view->pixmap != NULL && strcmp(view->pixmap, path) == 0)
+    {
+        /* same pixmap already set for this view.. */
+        return;
+    }
+    if (view->pixmap != NULL)
+        g_free(view->pixmap);
+    view->pixmap = g_strdup(path);
+
+#ifdef HAVE_GNOME
+    if (view->zvt)
+    {
+        zvt_term_set_background(ZVT_TERM(view->text), path, FALSE, FALSE);
+        return;
+    }
+#endif
+
+    if (*path == '\0')
+        pixmap = NULL;
+    else
+    {
+#if defined (HAVE_IMLIB) || defined (HAVE_GNOME)
+        mask = NULL;
+        img = gdk_imlib_load_image(path);
+        if (img == NULL)
+            pixmap = NULL;
+        else
+        {
+            gdk_imlib_render(img, img->rgb_width, img->rgb_height);
+            pixmap = gdk_imlib_move_image(img);
+            gdk_imlib_destroy_image(img);
+        }
+#else
+        pixmap = gdk_pixmap_create_from_xpm(view->text->window, &mask, NULL, path);
+#endif
+    }
+
+    style = gtk_style_copy(view->text->style);
+    gtk_style_ref(style);
+    style->bg_pixmap[GTK_STATE_NORMAL] = pixmap;
+    gtk_widget_set_style(view->text, style);
+    gtk_style_unref(style);
+}
+
+static void gui_window_view_set_background(GUI_WINDOW_VIEW_REC *view)
+{
+    GtkStyle *style;
+    gchar *path;
+
+    g_return_if_fail(view != NULL);
+
+#ifdef HAVE_GNOME
+    if (view->zvt)
+    {
+        if (toggle_use_transparency)
+        {
+            zvt_term_set_background(ZVT_TERM(view->text), 0, TRUE, toggle_shaded_transparency);
+            if (view->pixmap != NULL)
+            {
+                g_free(view->pixmap);
+                view->pixmap = NULL;
+            }
+            return;
+        }
+    }
+    else
+#endif
+    {
+        style = gtk_style_copy(view->text->style);
+        gtk_style_ref(style);
+        style->base[GTK_STATE_NORMAL] = bg_color;;
+        gtk_widget_set_style(view->text, style);
+        gtk_style_unref(style);
+    }
+
+    path = convert_home(background_pixmap);
+    gui_window_view_set_background_pixmap(view, path);
+    g_free(path);
+}
+
+static void init_colors(GtkWidget *window)
+{
+    gint n;
+
+    g_return_if_fail(window != NULL);
+
+    for (n = 0; n < sizeof(setup_colors)/sizeof(setup_colors[0]); n++)
+    {
+        setup_colors[n].pixel =
+            (gulong)((setup_colors[n].red & 0xff00)*256 +
+                     (setup_colors[n].green & 0xff00) +
+                     (setup_colors[n].blue & 0xff00)/256);
+        gdk_color_alloc(gtk_widget_get_colormap(window), &setup_colors[n]);
+    }
+
+    bg_color.pixel =
+        (gulong)((bg_color.red & 0xff00)*256 +
+                 (bg_color.green & 0xff00) +
+                 (bg_color.blue & 0xff00)/256);
+    gdk_color_alloc(gtk_widget_get_colormap(window), &bg_color);
+}
+
+#ifdef HAVE_GNOME
+static void init_zvt_colors(ZvtTerm *zvt)
+{
+    static gchar ansitab[16] = { 0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15 };
+    gushort zvt_red[18], zvt_green[18], zvt_blue[18];
+    gint num;
+
+    for (num = 0; num < 16; num++)
+    {
+        zvt_red[num] = (gushort) setup_colors[(gint) ansitab[num]].red;
+        zvt_green[num] = (gushort) setup_colors[(gint) ansitab[num]].green;
+        zvt_blue[num] = (gushort) setup_colors[(gint) ansitab[num]].blue;
+    }
+
+    zvt_red[16] = zvt_green[16] = zvt_blue[16] = 0xffff;
+    zvt_red[17] = zvt_green[17] = zvt_blue[17] = 0;
+
+    zvt_term_set_color_scheme(zvt, zvt_red, zvt_green, zvt_blue);
+}
+
+/* signal: button pressed in text window */
+static gint sig_text_butpress_zvt(GtkWidget *widget, GdkEventButton *event, WINDOW_REC *window)
+{
+    gint x, y, len;
+    gchar *text, *word;
+
+    g_return_val_if_fail(widget != NULL, 0);
+    g_return_val_if_fail(event != NULL, 0);
+    g_return_val_if_fail(window != NULL, 0);
+
+    x = event->x / ZVT_TERM(widget)->charwidth;
+    y = event->y / ZVT_TERM(widget)->charheight;
+
+    word = NULL;
+
+    text = zvt_term_get_buffer(ZVT_TERM(widget), &len, VT_SELTYPE_CHAR,
+                               0, y, ZVT_TERM(widget)->grid_width-1, y);
+    if (text != NULL && len > 0)
+    {
+        len = x;
+        if (!iswordcut(text[x]))
+            while (x > 0 && !iswordcut(text[x-1])) x--;
+        while (!iswordcut(text[len])) len++; len -= x;
+
+        word = g_new(gchar, len+1);
+        memcpy(word, text+x, len); word[len] = '\0';
+    }
+
+    if (event->button == 3 && toggle_show_menubar)
+    {
+        /* create popup menu */
+        window_popupmenu_create(window->active, word, event);
+        gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "button_press_event");
+    }
+    else if (word != NULL)
+    {
+        /* left mouse button clicked */
+        word_clicked(window, word, event->type == GDK_2BUTTON_PRESS, event->button, NULL);
+    }
+
+    if (word != NULL) g_free(word);
+    return 0;
+}
+#endif
+
+/* signal: button pressed in text window */
+static gint sig_text_butpress(GtkWidget *widget, GdkEventButton *event, GUI_WINDOW_VIEW_REC *view)
+{
+    static gboolean cludging = FALSE;
+    GdkEventButton kludge_event;
+
+    guint pos, spos, len;
+    gchar *text, *word;
+
+    g_return_val_if_fail(widget != NULL, 0);
+    g_return_val_if_fail(event != NULL, 0);
+    g_return_val_if_fail(view != NULL, 0);
+
+    /* so, here's the problem: we need know what word was just clicked, but
+       text widget haven't get button_press_event yet so cursor position is
+       still in the last clicked position.. We could use
+       gtk_signal_connect_after(), but if we create a popup menu with it,
+       text widget's selection gets broken, it never receives the
+       button_release_event .. We could also create the popup menu in
+       button_release_event but it seems to work in some weird way too ..
+       So this kludge seems to work best. */
+    if (cludging) return 0;
+
+    /* send faked left button click to text widget */
+    cludging = TRUE;
+    memcpy(&kludge_event, event, sizeof(kludge_event));
+    kludge_event.button = 1;
+    kludge_event.type = GDK_BUTTON_PRESS;
+    gtk_widget_event(widget, (GdkEvent *) &kludge_event);
+    kludge_event.type = GDK_BUTTON_RELEASE;
+    gtk_widget_event(widget, (GdkEvent *) &kludge_event);
+    cludging = FALSE;
+
+    /* finished, cursor is now in right position! */
+
+    len = gtk_text_get_length(GTK_TEXT(view->text));
+    pos = gtk_editable_get_position(GTK_EDITABLE(view->text));
+
+    word = NULL;
+    if (pos < len)
+    {
+        text = gtk_editable_get_chars(GTK_EDITABLE(view->text), pos < URL_MAX_LENGTH ? 0 : pos-URL_MAX_LENGTH,
+                                      pos+URL_MAX_LENGTH > len ? len : pos+URL_MAX_LENGTH);
+        len = spos = pos < URL_MAX_LENGTH ? pos : URL_MAX_LENGTH;
+        if (!iswordcut(text[spos]))
+            while (spos > 0 && !iswordcut(text[spos-1])) spos--;
+        while (!iswordcut(text[len])) len++; len -= spos;
+
+        word = g_new(gchar, len+1);
+        memcpy(word, text+spos, len); word[len] = '\0';
+        g_free(text);
+    }
+
+    if (event->button == 3 && toggle_show_menubar)
+    {
+        /* create popup menu */
+        window_popupmenu_create(view->window->active, word, event);
+        gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "button_press_event");
+    }
+    else if (word != NULL)
+    {
+        /* left mouse button clicked */
+        word_clicked(view->window, word, event->type == GDK_2BUTTON_PRESS, event->button, NULL);
+    }
+
+    if (word != NULL) g_free(word);
+    return 0;
+}
+
+GUI_WINDOW_VIEW_REC *gui_window_view_create(WINDOW_REC *window, GUI_WINDOW_REC *parent, GtkWidget *box)
+{
+    GUI_WINDOW_VIEW_REC *rec;
+    GtkWidget *scrollwin;
+
+    g_return_val_if_fail(parent != NULL, NULL);
+
+    rec = g_new0(GUI_WINDOW_VIEW_REC, 1);
+    parent->views = g_list_append(parent->views, rec);
+    window_views = g_list_append(window_views, rec);
+    window->gui_data = rec;
+
+    rec->window = window;
+    rec->windowset = parent;
+    rec->parent = parent->parent;;
+
+    /* Text window */
+    rec->zvt = toggle_use_zvt;
+#ifdef HAVE_GNOME
+    if (toggle_use_zvt)
+    {
+        GtkWidget *scrollbar;
+
+        rec->text = zvt_term_new();
+        gtk_signal_connect(GTK_OBJECT(rec->text), "button_press_event",
+                           GTK_SIGNAL_FUNC(sig_text_butpress_zvt), window);
+        zvt_term_set_scrollback(ZVT_TERM(rec->text), max_textwidget_lines);
+        zvt_term_set_fonts(ZVT_TERM(rec->text), font_normal, font_bold);
+        zvt_term_set_blink(ZVT_TERM(rec->text), FALSE);
+        gtk_box_pack_start(GTK_BOX(box), rec->text, TRUE, TRUE, 0);
+
+        scrollbar = gtk_vscrollbar_new(ZVT_TERM(rec->text)->adjustment);
+        gtk_box_pack_start(GTK_BOX(box), scrollbar, FALSE, FALSE, 0);
+    }
+    else
+#endif
+    {
+        rec->text = gtk_text_new(NULL, NULL);
+        gtk_signal_connect(GTK_OBJECT(rec->text), "button_press_event",
+                           GTK_SIGNAL_FUNC(sig_text_butpress), rec);
+        gtk_text_set_word_wrap(GTK_TEXT(rec->text), TRUE);
+
+        scrollwin = gtk_scrolled_window_new(NULL, NULL);
+        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrollwin),
+                                       GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+        gtk_box_pack_start(GTK_BOX(box), scrollwin, TRUE, TRUE, 0);
+        gtk_container_add(GTK_CONTAINER(scrollwin), rec->text);
+
+        init_colors(rec->text);
+    }
+
+    gui_window_view_set_background(rec);
+    return rec;
+}
+
+static gboolean gui_window_created(WINDOW_REC *window)
+{
+    GUI_WINDOW_VIEW_REC *view;
+    GtkWidget *popup;
+
+    g_return_val_if_fail(window != NULL, TRUE);
+
+    /* there's only one view after window is created.. */
+    view = WINDOW_GUI(window);
+
+#ifdef HAVE_GNOME
+    if (view->zvt)
+    {
+        gtk_widget_realize(view->text);
+        init_zvt_colors(ZVT_TERM(view->text));
+        vt_cursor_state(view->text, 0);
+    }
+#endif
+
+    if (!toggle_show_menubar)
+    {
+        /* add popup menu created by mainwindow */
+        popup = gtk_object_get_data(GTK_OBJECT(WINDOW_GUI(window)->parent->window), "popup");
+        if (popup != NULL) gnome_popup_menu_attach(popup, view->text, view->parent);
+    }
+
+    return TRUE;
+}
+
+void gui_window_view_destroy(GUI_WINDOW_VIEW_REC *view)
+{
+    WINDOW_REC *window;
+    GUI_WINDOW_REC *gui;
+
+    if (view->destroying) return;
+
+    window = view->window;
+    gui = view->windowset;
+    signal_emit("gui window view destroyed", 1, view);
+
+    view->destroying = TRUE;
+    ui_window_destroy(window);
+
+    gui->views = g_list_remove(gui->views, view);
+    window_views = g_list_remove(window_views, view);
+
+    if (view->pixmap != NULL) g_free(view->pixmap);
+    g_list_free(view->linepos);
+    g_free(view);
+
+    window->gui_data = NULL;
+
+    if (gui->views == NULL)
+        gui_windowset_destroy(gui);
+}
+
+static gboolean cmd_clear(gchar *data, SERVER_REC *server, CHANNEL_REC *channel)
+{
+    WINDOW_REC *window;
+    GUI_WINDOW_VIEW_REC *view;
+
+    g_return_val_if_fail(channel != NULL, FALSE);
+
+    window = CHANNEL_PARENT(channel);
+    view = WINDOW_GUI(window);
+
+#ifdef HAVE_GNOME
+    if (view->zvt)
+    {
+        zvt_term_set_scrollback(ZVT_TERM(view->text), 0);
+        zvt_term_feed(ZVT_TERM(view->text), "\033[H\033[2J", 7);
+        zvt_term_set_scrollback(ZVT_TERM(view->text), max_textwidget_lines);
+    }
+    else
+#endif
+    {
+        g_list_free(view->linepos);
+        view->linepos = NULL;
+        gtk_text_set_point(GTK_TEXT(view->text), 0);
+        gtk_text_forward_delete(GTK_TEXT(view->text), gtk_text_get_length(GTK_TEXT(view->text)));
+    }
+    window->lines = 0;
+
+    return TRUE;
+}
+
+static gboolean setup_changed(void)
+{
+    GList *tmp;
+
+    for (tmp = g_list_first(window_views); tmp != NULL; tmp = tmp->next)
+    {
+        GUI_WINDOW_VIEW_REC *view = tmp->data;
+
+        gui_window_view_set_background(view);
+#ifdef HAVE_GNOME
+        if (view->zvt)
+        {
+            zvt_term_set_fonts(ZVT_TERM(view->text), font_normal, font_bold);
+            init_zvt_colors(ZVT_TERM(view->text));
+        }
+#endif
+    }
+
+    return TRUE;
+}
+
+void gui_windows_view_init(void)
+{
+    signal_add("gui window created", (SIGNAL_FUNC) gui_window_created);
+    signal_add("setup changed", (SIGNAL_FUNC) setup_changed);
+    signal_add("command clear", (SIGNAL_FUNC) cmd_clear);
+}
+
+void gui_windows_view_deinit(void)
+{
+    signal_remove("gui window created", (SIGNAL_FUNC) gui_window_created);
+    signal_remove("setup changed", (SIGNAL_FUNC) setup_changed);
+    signal_remove("command clear", (SIGNAL_FUNC) cmd_clear);
+}
diff -Nru irssi-0.7.11/src/gui-gnome/gui-windows-view.h irssi-0.7.11-new/src/gui-gnome/gui-windows-view.h
--- irssi-0.7.11/src/gui-gnome/gui-windows-view.h	Thu Jan  1 02:00:00 1970
+++ irssi-0.7.11-new/src/gui-gnome/gui-windows-view.h	Sat Jun 12 17:23:39 1999
@@ -0,0 +1,34 @@
+#ifndef __GUI_WINDOWS_VIEW_H
+#define __GUI_WINDOWS_VIEW_H
+
+#define WINDOW_GUI(a) ((GUI_WINDOW_VIEW_REC *) ((a)->gui_data))
+
+struct _GUI_WINDOW_VIEW_REC
+{
+    WINDOW_REC *window;
+    GUI_WINDOW_REC *windowset;
+    MAIN_WINDOW_REC *parent;
+
+    GtkWidget *text;
+
+    gboolean zvt; /* text is a zvt widget */
+    gchar *pixmap; /* current background pixmap */
+
+    GList *linepos;
+    gint lastlinelen;
+
+    GtkWidget *snapshot;
+    gboolean destroying;
+};
+
+extern GList *window_views;
+
+void gui_windows_view_init(void);
+void gui_windows_view_deinit(void);
+
+GUI_WINDOW_VIEW_REC *gui_window_view_create(WINDOW_REC *window, GUI_WINDOW_REC *parent, GtkWidget *box);
+void gui_window_view_destroy(GUI_WINDOW_VIEW_REC *view);
+
+void gui_window_view_set_background_pixmap(GUI_WINDOW_VIEW_REC *view, gchar *path);
+
+#endif
diff -Nru irssi-0.7.11/src/gui-gnome/gui-windows.c irssi-0.7.11-new/src/gui-gnome/gui-windows.c
--- irssi-0.7.11/src/gui-gnome/gui-windows.c	Sat May 15 21:38:30 1999
+++ irssi-0.7.11-new/src/gui-gnome/gui-windows.c	Thu Jan  1 02:00:00 1970
@@ -1,750 +0,0 @@
-/*
- gui-windows.c : irssi
-
-    Copyright (C) 1999 Timo Sirainen
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include "irssi.h"
-
-#define iswordcut(a) (isspace((gint) a) || \
-    (a) == '\n' || (a) == '\0' || (a) == '"' || \
-    (a) == '(' || (a) == ')' || (a) == '[' || (a) == ']' || \
-    (a) == '<' || (a) == '>')
-
-#define URL_MAX_LENGTH 200 /*FIXME: no max. limits*/
-
-static gchar mode_flags[] = "spmint";
-static gchar *mode_tooltips[] =
-{
-    N_("Secret"),
-    N_("Private"),
-    N_("Moderated"),
-    N_("Joining needs an invitation"),
-    N_("No external messages"),
-    N_("Only operators can change the topic")
-};
-
-static void init_colors(GtkWidget *window)
-{
-    gint n;
-
-    g_return_if_fail(window != NULL);
-
-    for (n = 0; n < sizeof(setup_colors)/sizeof(setup_colors[0]); n++)
-    {
-        setup_colors[n].pixel =
-            (gulong)((setup_colors[n].red & 0xff00)*256 +
-                     (setup_colors[n].green & 0xff00) +
-                     (setup_colors[n].blue & 0xff00)/256);
-        gdk_color_alloc(gtk_widget_get_colormap(window), &setup_colors[n]);
-    }
-
-    bg_color.pixel =
-        (gulong)((bg_color.red & 0xff00)*256 +
-                 (bg_color.green & 0xff00) +
-                 (bg_color.blue & 0xff00)/256);
-    gdk_color_alloc(gtk_widget_get_colormap(window), &bg_color);
-}
-
-void gui_window_set_background_pixmap(WINDOW_REC *window, gchar *path)
-{
-    GUI_WINDOW_REC *gui;
-    GtkStyle *style;
-    GdkPixmap *pixmap;
-    GdkBitmap *mask;
-#if defined (HAVE_IMLIB) || defined (HAVE_GNOME)
-    GdkImlibImage *img;
-#endif
-
-    g_return_if_fail(window != NULL);
-    g_return_if_fail(path != NULL);
-
-    gui = WINDOW_GUI(window);
-    if (gui->pixmap != NULL && strcmp(gui->pixmap, path) == 0)
-    {
-        /* same pixmap already set for this window.. */
-        return;
-    }
-    if (gui->pixmap != NULL)
-        g_free(gui->pixmap);
-    gui->pixmap = g_strdup(path);
-
-#ifdef HAVE_GNOME
-    if (gui->zvt)
-    {
-        zvt_term_set_background(ZVT_TERM(gui->text), path, FALSE, FALSE);
-        return;
-    }
-#endif
-
-    if (*path == '\0')
-        pixmap = NULL;
-    else
-    {
-#if defined (HAVE_IMLIB) || defined (HAVE_GNOME)
-        mask = NULL;
-        img = gdk_imlib_load_image(path);
-        if (img == NULL)
-            pixmap = NULL;
-        else
-        {
-            gdk_imlib_render(img, img->rgb_width, img->rgb_height);
-            pixmap = gdk_imlib_move_image(img);
-            gdk_imlib_destroy_image(img);
-        }
-#else
-        pixmap = gdk_pixmap_create_from_xpm(gui->text->window, &mask, NULL, path);
-#endif
-    }
-
-    style = gtk_style_copy(gui->text->style);
-    gtk_style_ref(style);
-    style->bg_pixmap[GTK_STATE_NORMAL] = pixmap;
-    gtk_widget_set_style(gui->text, style);
-    gtk_style_unref(style);
-}
-
-static void gui_window_set_background(WINDOW_REC *window)
-{
-    GUI_WINDOW_REC *gui;
-    GtkStyle *style;
-    gchar *path;
-
-    g_return_if_fail(window != NULL);
-
-    gui = WINDOW_GUI(window);
-#ifdef HAVE_GNOME
-    if (gui->zvt)
-    {
-        if (toggle_use_transparency)
-        {
-            zvt_term_set_background(ZVT_TERM(gui->text), 0, TRUE, toggle_shaded_transparency);
-            if (gui->pixmap != NULL)
-            {
-                g_free(gui->pixmap);
-                gui->pixmap = NULL;
-            }
-            return;
-        }
-    }
-    else
-#endif
-    {
-        style = gtk_style_copy(gui->text->style);
-        gtk_style_ref(style);
-        style->base[GTK_STATE_NORMAL] = bg_color;;
-        gtk_widget_set_style(gui->text, style);
-        gtk_style_unref(style);
-    }
-
-    path = convert_home(background_pixmap);
-    gui_window_set_background_pixmap(window, path);
-    g_free(path);
-}
-
-#ifdef HAVE_GNOME
-static void init_zvt_colors(ZvtTerm *zvt)
-{
-    static gchar ansitab[16] = { 0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15 };
-    gushort zvt_red[18], zvt_green[18], zvt_blue[18];
-    gint num;
-
-    for (num = 0; num < 16; num++)
-    {
-        zvt_red[num] = (gushort) setup_colors[(gint) ansitab[num]].red;
-        zvt_green[num] = (gushort) setup_colors[(gint) ansitab[num]].green;
-        zvt_blue[num] = (gushort) setup_colors[(gint) ansitab[num]].blue;
-    }
-
-    zvt_red[16] = zvt_green[16] = zvt_blue[16] = 0xffff;
-    zvt_red[17] = zvt_green[17] = zvt_blue[17] = 0;
-
-    zvt_term_set_color_scheme(zvt, zvt_red, zvt_green, zvt_blue);
-}
-
-/* signal: button pressed in text window */
-static gint sig_text_butpress_zvt(GtkWidget *widget, GdkEventButton *event, WINDOW_REC *window)
-{
-    gint x, y, len;
-    gchar *text, *word;
-
-    g_return_val_if_fail(widget != NULL, 0);
-    g_return_val_if_fail(event != NULL, 0);
-    g_return_val_if_fail(window != NULL, 0);
-
-    x = event->x / ZVT_TERM(widget)->charwidth;
-    y = event->y / ZVT_TERM(widget)->charheight;
-
-    word = NULL;
-
-    text = zvt_term_get_buffer(ZVT_TERM(widget), &len, VT_SELTYPE_CHAR,
-                               0, y, ZVT_TERM(widget)->grid_width-1, y);
-    if (text != NULL && len > 0)
-    {
-        len = x;
-        if (!iswordcut(text[x]))
-            while (x > 0 && !iswordcut(text[x-1])) x--;
-        while (!iswordcut(text[len])) len++; len -= x;
-
-        word = g_new(gchar, len+1);
-        memcpy(word, text+x, len); word[len] = '\0';
-    }
-
-    if (event->button == 3 && toggle_show_menubar)
-    {
-        /* create popup menu */
-        window_popupmenu_create(window->active, word, event);
-        gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "button_press_event");
-    }
-    else if (word != NULL)
-    {
-        /* left mouse button clicked */
-        word_clicked(window, word, event->type == GDK_2BUTTON_PRESS, event->button, NULL);
-    }
-
-    if (word != NULL) g_free(word);
-    return 0;
-}
-#endif
-
-/* signal: button pressed in text window */
-static gint sig_text_butpress(GtkWidget *widget, GdkEventButton *event, WINDOW_REC *window)
-{
-    static gboolean cludging = FALSE;
-    GdkEventButton kludge_event;
-
-    guint pos, spos, len;
-    gchar *text, *word;
-
-    g_return_val_if_fail(widget != NULL, 0);
-    g_return_val_if_fail(event != NULL, 0);
-    g_return_val_if_fail(window != NULL, 0);
-
-    /* so, here's the problem: we need know what word was just clicked, but
-       text widget haven't get button_press_event yet so cursor position is
-       still in the last clicked position.. We could use
-       gtk_signal_connect_after(), but if we create a popup menu with it,
-       text widget's selection gets broken, it never receives the
-       button_release_event .. We could also create the popup menu in
-       button_release_event but it seems to work in some weird way too ..
-       So this kludge seems to work best. */
-    if (cludging) return 0;
-
-    /* send faked left button click to text widget */
-    cludging = TRUE;
-    memcpy(&kludge_event, event, sizeof(kludge_event));
-    kludge_event.button = 1;
-    kludge_event.type = GDK_BUTTON_PRESS;
-    gtk_widget_event(widget, (GdkEvent *) &kludge_event);
-    kludge_event.type = GDK_BUTTON_RELEASE;
-    gtk_widget_event(widget, (GdkEvent *) &kludge_event);
-    cludging = FALSE;
-
-    /* finished, cursor is now in right position! */
-
-    len = gtk_text_get_length(GTK_TEXT(WINDOW_GUI(window)->text));
-    pos = gtk_editable_get_position(GTK_EDITABLE(WINDOW_GUI(window)->text));
-
-    word = NULL;
-    if (pos < len)
-    {
-        text = gtk_editable_get_chars(GTK_EDITABLE(WINDOW_GUI(window)->text), pos < URL_MAX_LENGTH ? 0 : pos-URL_MAX_LENGTH,
-                                      pos+URL_MAX_LENGTH > len ? len : pos+URL_MAX_LENGTH);
-        len = spos = pos < URL_MAX_LENGTH ? pos : URL_MAX_LENGTH;
-        if (!iswordcut(text[spos]))
-            while (spos > 0 && !iswordcut(text[spos-1])) spos--;
-        while (!iswordcut(text[len])) len++; len -= spos;
-
-        word = g_new(gchar, len+1);
-        memcpy(word, text+spos, len); word[len] = '\0';
-        g_free(text);
-    }
-
-    if (event->button == 3 && toggle_show_menubar)
-    {
-        /* create popup menu */
-        window_popupmenu_create(window->active, word, event);
-        gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), "button_press_event");
-    }
-    else if (word != NULL)
-    {
-        /* left mouse button clicked */
-        word_clicked(window, word, event->type == GDK_2BUTTON_PRESS, event->button, NULL);
-    }
-
-    if (word != NULL) g_free(word);
-    return 0;
-}
-
-static gint sig_topicentry_press(GtkWidget *entry, GdkEventButton *event)
-{
-    gboolean editable;
-
-    g_return_val_if_fail(entry != NULL, 0);
-    g_return_val_if_fail(event != NULL, 0);
-
-    if (event->type == GDK_2BUTTON_PRESS)
-    {
-        editable = !(gboolean) GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT(entry), "editable"));
-        gtk_object_set_data(GTK_OBJECT(entry), "editable", GINT_TO_POINTER((gint) editable));
-        gtk_entry_set_editable(GTK_ENTRY(entry), editable);
-    }
-
-    return 0;
-}
-
-static void sig_topicentry_activated(GtkWidget *entry, WINDOW_REC *window)
-{
-    CHANNEL_REC *channel;
-
-    g_return_if_fail(entry != NULL);
-    g_return_if_fail(window != NULL);
-
-    channel = window->active;
-    if (channel == NULL || (!channel->chanop && channel->mode_optopic))
-    {
-        /* can't change topic. */
-        gtk_entry_set_text(GTK_ENTRY(entry),
-                           (channel == NULL || channel->topic == NULL) ?
-                           "" : channel->topic);
-        return;
-    }
-
-    signal_emit("command topic", 3, gtk_entry_get_text(GTK_ENTRY(entry)),
-                window->active->server, window->active);
-}
-
-static void sig_modebutton_toggled(GtkToggleButton *button, gint mode)
-{
-    WINDOW_REC *window;
-    NICK_REC *nick;
-    GString *str;
-
-    g_return_if_fail(button != NULL);
-    if (gtk_object_get_data(GTK_OBJECT(button), "toggling")) return;
-
-    window = gtk_object_get_data(GTK_OBJECT(button), "window");
-    g_return_if_fail(window->active != NULL);
-
-    nick = nicklist_find(window->active, window->active->server->nick);
-    if (!window->active->chanop)
-    {
-        /* can't change mode */
-        gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(TRUE));
-        gtk_toggle_button_set_active(button, !button->active);
-        gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(FALSE));
-        return;
-    }
-
-    str = g_string_new(NULL);
-    g_string_sprintf(str, "* %c%c", button->active ? '+' : '-', mode_flags[mode]);
-
-    gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(TRUE));
-    signal_emit("command mode", 3, str->str, window->active->server, window->active);
-    g_string_free(str, TRUE);
-    gtk_object_set_data(GTK_OBJECT(button), "toggling", GINT_TO_POINTER(FALSE));
-}
-
-WINDOW_REC *gui_window_create(MAIN_WINDOW_REC *parent)
-{
-    WINDOW_REC *rec;
-    GUI_WINDOW_REC *gui;
-    GtkWidget *hbox, *scrollwin, *label;
-    GtkTooltips *tooltips;
-    gint num;
-
-    if (parent == NULL) parent = mainwindow_create();
-
-    rec = ui_window_create();
-    g_return_val_if_fail(rec != NULL, NULL);
-
-    gui = g_new0(GUI_WINDOW_REC, 1);
-    rec->gui_data = gui;
-    gui->parent = parent;
-
-    if (parent->children == NULL) parent->active = rec;
-    parent->children = g_list_append(parent->children, rec);
-
-    gui->window = gtk_vbox_new(FALSE, 2);
-    gtk_container_border_width(GTK_CONTAINER(gui->window), 2);
-
-    /* Add channel topic and modes */
-    gui->channelwidget = gtk_hbox_new(FALSE, 0);
-    gtk_box_pack_start(GTK_BOX(gui->window), gui->channelwidget, FALSE, FALSE, 0);
-
-    gui->serverlabel = gtk_label_new("");
-    gtk_box_pack_start(GTK_BOX(gui->channelwidget), gui->serverlabel, FALSE, FALSE, 0);
-
-    gui->topicentry = gtk_entry_new();
-    gtk_entry_set_editable(GTK_ENTRY(gui->topicentry), FALSE);
-    gtk_signal_connect(GTK_OBJECT(gui->topicentry), "button_press_event",
-                       GTK_SIGNAL_FUNC(sig_topicentry_press), rec);
-    gtk_signal_connect(GTK_OBJECT(gui->topicentry), "activate",
-                       GTK_SIGNAL_FUNC(sig_topicentry_activated), rec);
-    gtk_box_pack_start(GTK_BOX(gui->channelwidget), gui->topicentry, TRUE, TRUE, 3);
-
-    tooltips = gtk_tooltips_new();
-
-    for (num = 0; num < 6; num++)
-    {
-        gchar str[2];
-
-        str[0] = toupper(mode_flags[num]); str[1] = '\0';
-        gui->modebuttons[num] = gtk_toggle_button_new_with_label(str);
-        gtk_tooltips_set_tip(tooltips, gui->modebuttons[num], mode_tooltips[num], NULL);
-        gtk_widget_set_usize(gui->modebuttons[num], 20, -1);
-        gtk_object_set_data(GTK_OBJECT(gui->modebuttons[num]), "window", rec);
-        gtk_signal_connect(GTK_OBJECT(gui->modebuttons[num]), "toggled",
-                           GTK_SIGNAL_FUNC(sig_modebutton_toggled), GINT_TO_POINTER(num));
-        gtk_box_pack_start(GTK_BOX(gui->channelwidget), gui->modebuttons[num], FALSE, FALSE, 0);
-    }
-
-    /* Text window */
-    hbox = gtk_hbox_new(FALSE, 3);
-    gtk_box_pack_start(GTK_BOX(gui->window), hbox, TRUE, TRUE, 0);
-
-    gui->zvt = toggle_use_zvt;
-#ifdef HAVE_GNOME
-    if (toggle_use_zvt)
-    {
-        GtkWidget *scrollbar;
-
-        gui->text = zvt_term_new();
-        gtk_signal_connect(GTK_OBJECT(gui->text), "button_press_event",
-                           GTK_SIGNAL_FUNC(sig_text_butpress_zvt), rec);
-        zvt_term_set_scrollback(ZVT_TERM(gui->text), max_textwidget_lines);
-        zvt_term_set_fonts(ZVT_TERM(gui->text), font_normal, font_bold);
-        zvt_term_set_blink(ZVT_TERM(gui->text), FALSE);
-        gtk_box_pack_start(GTK_BOX(hbox), gui->text, TRUE, TRUE, 0);
-
-        scrollbar = gtk_vscrollbar_new(ZVT_TERM(gui->text)->adjustment);
-        gtk_box_pack_start(GTK_BOX(hbox), scrollbar, FALSE, FALSE, 0);
-    }
-    else
-#endif
-    {
-        gui->text = gtk_text_new(NULL, NULL);
-        gtk_signal_connect(GTK_OBJECT(gui->text), "button_press_event",
-                           GTK_SIGNAL_FUNC(sig_text_butpress), rec);
-        gtk_text_set_word_wrap(GTK_TEXT(gui->text), TRUE);
-
-        scrollwin = gtk_scrolled_window_new(NULL, NULL);
-        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrollwin),
-                                       GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
-        gtk_box_pack_start(GTK_BOX(hbox), scrollwin, TRUE, TRUE, 0);
-        gtk_container_add(GTK_CONTAINER(scrollwin), gui->text);
-
-        init_colors(gui->text);
-    }
-    gui_window_set_background(rec);
-
-    gtk_widget_show_all(gui->window);
-
-    /* Add nick list */
-    gui->nickscrollbox = gtk_scrolled_window_new(NULL, NULL);
-    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gui->nickscrollbox),
-                                   GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-    gtk_box_pack_start(GTK_BOX(hbox), gui->nickscrollbox, FALSE, FALSE, 0);
-
-    gui->nicklist = gtk_clist_new(1);
-    gtk_container_add(GTK_CONTAINER(gui->nickscrollbox), gui->nicklist);
-    gtk_widget_show(gui->nicklist);
-
-    gtk_widget_set_usize(gui->nickscrollbox, 120, -1);
-
-    label = gtk_label_new(_("(none)"));
-    gtk_widget_show(label);
-
-    if (g_list_first(parent->children)->next == NULL)
-    {
-        /* only one child, don't show the notebook tabs.. */
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(parent->notebook), FALSE);
-        gtk_notebook_set_show_border(GTK_NOTEBOOK(parent->notebook), FALSE);
-    }
-    else if (g_list_first(parent->children)->next->next == NULL)
-    {
-        /* two children, show the notebook tabs.. */
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(parent->notebook), TRUE);
-        gtk_notebook_set_show_border(GTK_NOTEBOOK(parent->notebook), TRUE);
-    }
-
-    gtk_notebook_append_page(GTK_NOTEBOOK(parent->notebook), gui->window, label);
-
-#ifdef HAVE_GNOME
-    if (gui->zvt)
-    {
-        gtk_widget_realize(gui->text);
-        init_zvt_colors(ZVT_TERM(gui->text));
-        vt_cursor_state(gui->text, 0);
-    }
-#endif
-
-    if (!toggle_show_menubar)
-    {
-        GtkWidget *popup;
-
-        /* add popup menu created by mainwindow */
-        popup = gtk_object_get_data(GTK_OBJECT(parent->window), "popup");
-        if (popup != NULL) gnome_popup_menu_attach(popup, gui->text, parent);
-    }
-
-    gtk_widget_hide(gui->channelwidget);
-
-    signal_emit("gui window created", 1, rec);
-    return rec;
-}
-
-void gui_window_destroy(WINDOW_REC *window)
-{
-    MAIN_WINDOW_REC *parent;
-    GUI_WINDOW_REC *gui;
-    gint page;
-
-    g_return_if_fail(window != NULL);
-    if (WINDOW_GUI(window)->destroying) return;
-
-    gui = WINDOW_GUI(window);
-    parent = gui->parent;
-    parent->children = g_list_remove(parent->children, window);
-
-    signal_emit("gui window destroyed", 1, window);
-
-    gui->destroying = TRUE;
-    ui_window_destroy(window);
-
-    page = gtk_notebook_page_num(GTK_NOTEBOOK(parent->notebook), gui->window);
-    gtk_notebook_remove_page(GTK_NOTEBOOK(parent->notebook), page);
-
-    if (gui->pixmap != NULL) g_free(gui->pixmap);
-    g_free(gui);
-    window->gui_data = NULL;
-
-    if (parent->children == NULL)
-        mainwindow_destroy(parent);
-    else if (g_list_length(parent->children) == 1)
-    {
-        /* only one child left, hide the notebook tabs.. */
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(parent->notebook), FALSE);
-        gtk_notebook_set_show_border(GTK_NOTEBOOK(parent->notebook), FALSE);
-    }
-}
-
-static gboolean gui_window_server_changed(WINDOW_REC *window)
-{
-    MAIN_WINDOW_REC *parent;
-    SERVER_REC *server;
-    gint num;
-
-    g_return_val_if_fail(window != NULL, FALSE);
-
-    parent = WINDOW_GUI(window)->parent;
-    server = window->active->server;
-
-    if (parent->usermodes[0] == NULL) return TRUE;
-
-    for (num = 0; num < 4; num++)
-        gtk_object_set_data(GTK_OBJECT(parent->usermodes[num]), "toggling", GINT_TO_POINTER(TRUE));
-
-    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[0]),
-                                  server == NULL ? FALSE : server->usermode_away);
-    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[1]),
-                                  server == NULL ? FALSE : server->usermode_invisible);
-    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[2]),
-                                  server == NULL ? FALSE : server->usermode_wallops);
-    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(parent->usermodes[3]),
-                                  server == NULL ? FALSE : server->usermode_servernotes);
-
-    for (num = 0; num < 4; num++)
-        gtk_object_set_data(GTK_OBJECT(parent->usermodes[num]), "toggling", GINT_TO_POINTER(FALSE));
-
-    return TRUE;
-}
-
-static gboolean gui_windows_usermode_changed(SERVER_REC *server)
-{
-    GList *winlist;
-
-    for (winlist = g_list_first(mainwindows); winlist != NULL; winlist = winlist->next)
-    {
-        MAIN_WINDOW_REC *rec = winlist->data;
-
-        if (server == rec->active->active->server)
-            signal_emit("window server changed", 1, rec->active);
-    }
-
-    return TRUE;
-}
-
-static gboolean cmd_clear(gchar *data, SERVER_REC *server, CHANNEL_REC *channel)
-{
-    WINDOW_REC *window;
-    GUI_WINDOW_REC *gui;
-
-    g_return_val_if_fail(channel != NULL, FALSE);
-
-    window = CHANNEL_PARENT(channel);
-    gui = WINDOW_GUI(window);
-
-#ifdef HAVE_GNOME
-    if (gui->zvt)
-    {
-        zvt_term_set_scrollback(ZVT_TERM(gui->text), 0);
-        zvt_term_feed(ZVT_TERM(gui->text), "\033[H\033[2J", 7);
-        zvt_term_set_scrollback(ZVT_TERM(gui->text), max_textwidget_lines);
-    }
-    else
-#endif
-    {
-        g_list_free(gui->linepos);
-        gui->linepos = NULL;
-        gtk_text_set_point(GTK_TEXT(gui->text), 0);
-        gtk_text_forward_delete(GTK_TEXT(gui->text), gtk_text_get_length(GTK_TEXT(gui->text)));
-    }
-    window->lines = 0;
-
-    return TRUE;
-}
-
-static gboolean signal_window_focused(WINDOW_REC *window)
-{
-    MAIN_WINDOW_REC *mainwindow;
-    GUI_WINDOW_REC *gui;
-    CHANNEL_REC *channel;
-
-    g_return_val_if_fail(window != NULL, FALSE);
-
-    mainwindow = WINDOW_GUI(window)->parent;
-    channel = window->active;
- 
-    gui = WINDOW_GUI(mainwindow->active);
-
-    /* remove old extra menus */
-    if (mainwindow->extramenu != NULL)
-    {
-        window_menus_remove(mainwindow, mainwindow->extramenu);
-        g_free(mainwindow->extramenu);
-        mainwindow->extramenu = NULL;
-    }
-    if (channel == NULL) return TRUE;
-
-    if (channel->type == CHANNEL_TYPE_CHANNEL)
-    {
-        /* Add channel menu */
-        mainwindow->extramenu = g_strdup(channel_menu[0].label);
-        window_menus_insert(mainwindow, NULL, channel_menu, channel);
-        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(channel_submenu[2].widget),
-                                      GTK_WIDGET_VISIBLE(gui->nickscrollbox));
-        gtk_widget_show(gui->channelwidget);
-    }
-    else
-    {
-        gtk_widget_hide(gui->nickscrollbox);
-        gtk_widget_hide(gui->channelwidget);
-        if (channel->type == CHANNEL_TYPE_QUERY)
-        {
-            /* Add query menu */
-            mainwindow->extramenu = g_strdup(query_menu[0].label);
-            window_menus_insert(mainwindow, NULL, query_menu, channel);
-        }
-    }
-
-    if (CHANNEL_GUI(channel)->servermenu)
-    {
-        /* change server selection */
-        gtk_option_menu_set_history(GTK_OPTION_MENU(mainwindow->servermenu),
-                                    g_list_index(servers, channel->server));
-        gtk_widget_show(mainwindow->servermenu);
-    }
-    else
-        gtk_widget_hide(mainwindow->servermenu);
-
-    /* draw title bar */
-    signal_emit("channel topic changed", 1, window->active);
-
-    return TRUE;
-}
-
-static gboolean gui_windows_setup_changed(void)
-{
-    GList *tmp;
-
-    for (tmp = g_list_first(windows); tmp != NULL; tmp = tmp->next)
-    {
-        WINDOW_REC *rec = tmp->data;
-
-        gui_window_set_background(rec);
-#ifdef HAVE_GNOME
-        if (WINDOW_GUI(rec)->zvt)
-        {
-            zvt_term_set_fonts(ZVT_TERM(WINDOW_GUI(rec)->text), font_normal, font_bold);
-            init_zvt_colors(ZVT_TERM(WINDOW_GUI(rec)->text));
-        }
-#endif
-    }
-
-    return TRUE;
-}
-
-static gboolean gui_server_looking(SERVER_REC *server)
-{
-    GList *tmp, *sub;
-
-    g_return_val_if_fail(server != NULL, FALSE);
-
-    /* try to keep some server assigned to server menus.. */
-    for (tmp = g_list_first(windows); tmp != NULL; tmp = tmp->next)
-    {
-        WINDOW_REC *win = tmp->data;
-        gboolean changed;
-
-        changed = FALSE;
-        for (sub = g_list_first(win->channels); sub != NULL; sub = sub->next)
-        {
-            CHANNEL_REC *chan = sub->data;
-
-            if (chan->server == NULL)
-            {
-                chan->server = server;
-                if (!changed)
-                    signal_emit("window server changed", 1, win);
-                changed = TRUE;
-            }
-        }
-    }
-
-    return TRUE;
-}
-
-void gui_windows_init(void)
-{
-    signal_add("setup changed", (SIGNAL_FUNC) gui_windows_setup_changed);
-    signal_add("user mode changed", (SIGNAL_FUNC) gui_windows_usermode_changed);
-    signal_add("window server changed", (SIGNAL_FUNC) gui_window_server_changed);
-    signal_add("window focused", (SIGNAL_FUNC) signal_window_focused);
-    signal_add("command clear", (SIGNAL_FUNC) cmd_clear);
-    signal_add("server looking", (SIGNAL_FUNC) gui_server_looking);
-}
-
-void gui_windows_deinit(void)
-{
-    signal_remove("setup changed", (SIGNAL_FUNC) gui_windows_setup_changed);
-    signal_remove("user mode changed", (SIGNAL_FUNC) gui_windows_usermode_changed);
-    signal_remove("window server changed", (SIGNAL_FUNC) gui_window_server_changed);
-    signal_remove("window focused", (SIGNAL_FUNC) signal_window_focused);
-    signal_remove("command clear", (SIGNAL_FUNC) cmd_clear);
-    signal_remove("server looking", (SIGNAL_FUNC) gui_server_looking);
-}
diff -Nru irssi-0.7.11/src/gui-gnome/gui-windows.h irssi-0.7.11-new/src/gui-gnome/gui-windows.h
--- irssi-0.7.11/src/gui-gnome/gui-windows.h	Thu May 13 13:24:58 1999
+++ irssi-0.7.11-new/src/gui-gnome/gui-windows.h	Thu Jan  1 02:00:00 1970
@@ -1,44 +0,0 @@
-#ifndef __GUI_WINDOWS_H
-#define __GUI_WINDOWS_H
-
-#define WINDOW_GUI(a) ((GUI_WINDOW_REC *) ((a)->gui_data))
-
-typedef struct
-{
-    MAIN_WINDOW_REC *parent;
-
-    GtkWidget *window;
-    GtkWidget *text;
-
-    gboolean zvt; /* text is a zvt widget */
-    gchar *pixmap; /* current background pixmap */
-
-    GtkWidget *channelwidget;
-    GtkWidget *serverlabel;
-    GtkWidget *topicentry;
-    GtkWidget *modebuttons[6];
-
-    /* nicklist */
-    GtkWidget *nickscrollbox;
-    GtkWidget *nicklist;
-    GdkPixmap *op_pixmap, *voice_pixmap;
-    GdkBitmap *op_mask, *voice_mask;
-
-    GList *linepos;
-    gint lastlinelen;
-
-    GtkWidget *snapshot;
-    gboolean destroying;
-    gfloat sb_value; /* to fix those scrollbar problems... */
-}
-GUI_WINDOW_REC;
-
-void gui_windows_init(void);
-void gui_windows_deinit(void);
-
-WINDOW_REC *gui_window_create(MAIN_WINDOW_REC *parent);
-void gui_window_destroy(WINDOW_REC *window);
-
-void gui_window_set_background_pixmap(WINDOW_REC *window, gchar *path);
-
-#endif
